<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>Native on Maciej Procyk</title><link>https://procyk.in/tags/native/</link><description>Recent content in Native on Maciej Procyk</description><generator>Hugo -- gohugo.io</generator><language>en</language><lastBuildDate>Sun, 05 Nov 2023 00:00:00 +0000</lastBuildDate><atom:link href="https://procyk.in/tags/native/index.xml" rel="self" type="application/rss+xml"/><item><title>Kotlin/Native &amp; Rust interoperability</title><link>https://procyk.in/post/kotlin-native-rust-interop/</link><pubDate>Sun, 05 Nov 2023 00:00:00 +0000</pubDate><guid>https://procyk.in/post/kotlin-native-rust-interop/</guid><description>&lt;img src="https://procyk.in/img/featured/featured-kotlin-rust.jpg" alt="Featured image of post Kotlin/Native &amp; Rust interoperability
" />&lt;h1 id="kotlinnative--rust-interoperability">Kotlin/Native &amp;amp; Rust interoperability
&lt;/h1>&lt;p>Let&amp;rsquo;s start with forking the &lt;a class="link" href="https://github.com/avan1235/kotlin-native-rust-interop" target="_blank" rel="noopener"
>project on GitHub&lt;/a> and cloning it to your device to try it yourself.&lt;/p>
&lt;h2 id="main-goal">Main goal
&lt;/h2>&lt;p>We want to build an executable in Kotlin to use the language capabilities and our knowledge, but at
the same time deliver fully independent of JVM solution, which can be as small as few megabytes.&lt;/p>
&lt;p>However, not every functionality can be easily handled in Kotlin, so sometimes it&amp;rsquo;s just more convenient to
prepare some external library, expose its symbols with C ABI and call them in expected places in Kotlin.
We would prefer to build a static library, which can then be statically linked to the final executable,
to make sure that the end user needs only a single binary to run our program.&lt;/p>
&lt;p>In our specific example, we see how to write a CLI tool in Kotlin/Native, but prepare an external library
in Rust. The external library is responsible for unzipping the given file to a specific location. In Kotlin,
we handle the rest of business logic, which (for the sake of simplicity) is just proper
handling of program arguments and deleting some files, to see how the Kotlin/Native libraries can be used.&lt;/p>
&lt;h2 id="project-configuration">Project configuration
&lt;/h2>&lt;p>Let&amp;rsquo;s start with having look at the project structure that&amp;rsquo;s worth explaining what files
and directories are responsible for which part of the project configuration.&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt"> 1
&lt;/span>&lt;span class="lnt"> 2
&lt;/span>&lt;span class="lnt"> 3
&lt;/span>&lt;span class="lnt"> 4
&lt;/span>&lt;span class="lnt"> 5
&lt;/span>&lt;span class="lnt"> 6
&lt;/span>&lt;span class="lnt"> 7
&lt;/span>&lt;span class="lnt"> 8
&lt;/span>&lt;span class="lnt"> 9
&lt;/span>&lt;span class="lnt">10
&lt;/span>&lt;span class="lnt">11
&lt;/span>&lt;span class="lnt">12
&lt;/span>&lt;span class="lnt">13
&lt;/span>&lt;span class="lnt">14
&lt;/span>&lt;span class="lnt">15
&lt;/span>&lt;span class="lnt">16
&lt;/span>&lt;span class="lnt">17
&lt;/span>&lt;span class="lnt">18
&lt;/span>&lt;span class="lnt">19
&lt;/span>&lt;span class="lnt">20
&lt;/span>&lt;span class="lnt">21
&lt;/span>&lt;span class="lnt">22
&lt;/span>&lt;span class="lnt">23
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-fallback" data-lang="fallback">&lt;span class="line">&lt;span class="cl">├── build.gradle.kts
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">├── gradle
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">│   └── wrapper
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">│   ├── gradle-wrapper.jar
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">│   └── gradle-wrapper.properties
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">├── gradle.properties
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">├── gradlew
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">├── gradlew.bat
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">├── README.md
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">├── rust_lib
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">│   ├── build.rs
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">│   ├── Cargo.toml
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">│   └── src
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">│   └── lib.rs
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">├── settings.gradle.kts
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">└── src
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> ├── nativeInterop
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> │   └── cinterop
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> │   └── librust_lib.def
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> └── nativeMain
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> └── kotlin
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> ├── Main.kt
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> └── ReportedError.kt
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;h3 id="rust-library">Rust library
&lt;/h3>&lt;p>First of all, we include the &lt;a class="link" href="https://github.com/avan1235/kotlin-native-rust-interop/tree/master/rust_lib" target="_blank" rel="noopener"
>rust_lib&lt;/a> directory in our root. It contains the Rust project exporting static
library.
Its &lt;a class="link" href="https://github.com/avan1235/kotlin-native-rust-interop/tree/master/rust_lib/Cargo.toml" target="_blank" rel="noopener"
>Cargo.ml&lt;/a> explicitly says that the build result is &lt;code>staticlib&lt;/code>, for which release profile
has multiple final binary size oriented optimizations enabled. It also declares two dependencies:&lt;/p>
&lt;ul>
&lt;li>&lt;code>zip&lt;/code> being our business-specific dependency that simplifies the implementation of unzipping files&lt;/li>
&lt;li>&lt;code>cbindgen&lt;/code> being must-have dependency, which is responsible for exporting the &lt;code>.h&lt;/code> header file based on the
definitions from our library. You
can find a proper file &lt;a class="link" href="https://github.com/avan1235/kotlin-native-rust-interop/tree/master/rust_lib/target/rust_lib.h" target="_blank" rel="noopener"
>rust_lib.h&lt;/a> after executing &lt;code>buildRustLib&lt;/code> Gradle task.
Additionally, in &lt;a class="link" href="https://github.com/avan1235/kotlin-native-rust-interop/tree/master/rust_lib/build.rs" target="_blank" rel="noopener"
>build.rs&lt;/a> we include actual logics responsible for this process.&lt;/li>
&lt;/ul>
&lt;p>The &lt;a class="link" href="https://github.com/avan1235/kotlin-native-rust-interop/tree/master/rust_lib/src/lib.rs" target="_blank" rel="noopener"
>lib.rs&lt;/a> file contains, on the other hand, the actual definition of our
exported library. We need to specify all the functions&amp;rsquo; symbols as &lt;code>pub extern &amp;quot;C&amp;quot;&lt;/code> and add the
&lt;code>#[no_mangle]&lt;/code> macro to make them accessible via C ABI, as well as it&amp;rsquo;s crucial to use a proper type
for function arguments and returned value – they need to be compatible with the ones that C language would
produce.&lt;/p>
&lt;p>That implies the proper conversion of arguments, to make them friendly to Rust. In our case we work
with string values, which are passed as &lt;code>char *out_path&lt;/code>. It&amp;rsquo;s important to use &lt;code>unsafe { CStr::from_ptr(chars) };&lt;/code>
to convert them to &lt;code>&amp;amp;str&lt;/code> – notice that using &lt;code>unsafe { CString::from_raw(chars) };&lt;/code> is an incorrect approach as
it leads to invalid free operation (we can find in &lt;code>CString::from_raw&lt;/code> documentation that
&lt;code>If you need to borrow a string that was allocated by foreign code, use CStr.&lt;/code>)&lt;/p>
&lt;p>The final static library file, produced from our &lt;code>rust_lib&lt;/code>, will be available in &lt;a class="link" href="https://github.com/avan1235/kotlin-native-rust-interop/tree/master/rust_lib/target/release" target="_blank" rel="noopener"
>release&lt;/a>
directory, and we&amp;rsquo;re going to use it while compiling final binary, to find the symbols defined in
header file.&lt;/p>
&lt;h3 id="gradle-project">Gradle project
&lt;/h3>&lt;p>We configure our root project with Gradle, using Kotlin Multiplatform Plugin to enable compilation to native
targets. The main configuration file &lt;a class="link" href="https://github.com/avan1235/kotlin-native-rust-interop/tree/master/build.gradle.kts" target="_blank" rel="noopener"
>build.gradle.kts&lt;/a> has a few, quite interesting definitions,
that we&amp;rsquo;ve used to achieve our goal of building independent binary.&lt;/p>
&lt;p>We use &lt;code>DefaultNativePlatform&lt;/code> helper to read current host OS and architecture and configure the
compilation for our platform. Inside the &lt;code>kotlin { ... }&lt;/code> block we configure the native target to
&lt;code>host&lt;/code> and then configure it inside the &lt;code>target { ... }&lt;/code> block. There are two parts of the configuration that
play the main role in our final result.&lt;/p>
&lt;p>The first part&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt"> 1
&lt;/span>&lt;span class="lnt"> 2
&lt;/span>&lt;span class="lnt"> 3
&lt;/span>&lt;span class="lnt"> 4
&lt;/span>&lt;span class="lnt"> 5
&lt;/span>&lt;span class="lnt"> 6
&lt;/span>&lt;span class="lnt"> 7
&lt;/span>&lt;span class="lnt"> 8
&lt;/span>&lt;span class="lnt"> 9
&lt;/span>&lt;span class="lnt">10
&lt;/span>&lt;span class="lnt">11
&lt;/span>&lt;span class="lnt">12
&lt;/span>&lt;span class="lnt">13
&lt;/span>&lt;span class="lnt">14
&lt;/span>&lt;span class="lnt">15
&lt;/span>&lt;span class="lnt">16
&lt;/span>&lt;span class="lnt">17
&lt;/span>&lt;span class="lnt">18
&lt;/span>&lt;span class="lnt">19
&lt;/span>&lt;span class="lnt">20
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-kotlin" data-lang="kotlin">&lt;span class="line">&lt;span class="cl">&lt;span class="n">compilations&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="n">getByName&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="s2">&amp;#34;main&amp;#34;&lt;/span>&lt;span class="p">).&lt;/span>&lt;span class="n">cinterops&lt;/span> &lt;span class="p">{&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">create&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="s2">&amp;#34;librust_lib&amp;#34;&lt;/span>&lt;span class="p">)&lt;/span> &lt;span class="p">{&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="k">val&lt;/span> &lt;span class="py">buildRustLib&lt;/span> &lt;span class="k">by&lt;/span> &lt;span class="n">tasks&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="n">creating&lt;/span> &lt;span class="p">{&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">exec&lt;/span> &lt;span class="p">{&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">executable&lt;/span> &lt;span class="p">=&lt;/span> &lt;span class="n">cargoAbsolutePath&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">args&lt;/span>&lt;span class="p">(&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="s2">&amp;#34;build&amp;#34;&lt;/span>&lt;span class="p">,&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="s2">&amp;#34;--manifest-path&amp;#34;&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="n">projectFile&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="s2">&amp;#34;rust_lib/Cargo.toml&amp;#34;&lt;/span>&lt;span class="p">),&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="s2">&amp;#34;--package&amp;#34;&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="s2">&amp;#34;rust_lib&amp;#34;&lt;/span>&lt;span class="p">,&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="s2">&amp;#34;--lib&amp;#34;&lt;/span>&lt;span class="p">,&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="s2">&amp;#34;--release&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="p">)&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="p">}&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="p">}&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">tasks&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="n">getByName&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">interopProcessingTaskName&lt;/span>&lt;span class="p">)&lt;/span> &lt;span class="p">{&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">dependsOn&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">buildRustLib&lt;/span>&lt;span class="p">)&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="p">}&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">header&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">projectFile&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="s2">&amp;#34;rust_lib/target/rust_lib.h&amp;#34;&lt;/span>&lt;span class="p">))&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="p">}&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="p">}&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>is responsible for interoperability between Kotlin and C symbols. We create the &lt;code>librust_lib&lt;/code> cinterop
and configure the header location manually with &lt;code>projectFile&lt;/code> function to get absolute path of the header,
having the current location of project directory. Moreover, we add extra task named
&lt;code>buildRustLib&lt;/code>, which calls &lt;code>cargo&lt;/code> command to build our Rust library before the cinterop task is executed.
To make sure we have our header file available, we explicitly define the dependency on &lt;code>interopProcessingTaskName&lt;/code>.
It&amp;rsquo;s worth mentioning here, that we include empty &lt;a class="link" href="https://github.com/avan1235/kotlin-native-rust-interop/tree/master/src/nativeInterop/cinterop/librust_lib.def" target="_blank" rel="noopener"
>librust_lib.def&lt;/a> file
in our project. It&amp;rsquo;s required by project structure, as described in
the &lt;a class="link" href="https://kotlinlang.org/docs/native-app-with-c-and-libcurl.html#add-interoperability-to-the-build-process" target="_blank" rel="noopener"
>official documentation example&lt;/a>.
However, we want to define the required &lt;code>header&lt;/code> relatively to project directory, and it seems that
working and nice approach is to configure it directly in our build script.&lt;/p>
&lt;p>The second step — configuring final executable with&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;span class="lnt">2
&lt;/span>&lt;span class="lnt">3
&lt;/span>&lt;span class="lnt">4
&lt;/span>&lt;span class="lnt">5
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-kotlin" data-lang="kotlin">&lt;span class="line">&lt;span class="cl">&lt;span class="n">binaries&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="n">executable&lt;/span> &lt;span class="p">{&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">entryPoint&lt;/span> &lt;span class="p">=&lt;/span> &lt;span class="s2">&amp;#34;main&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">baseName&lt;/span> &lt;span class="p">=&lt;/span> &lt;span class="s2">&amp;#34;kotlin-tool&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">linkerOpts&lt;/span> &lt;span class="o">+=&lt;/span> &lt;span class="n">rustLibAbsolutePath&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="p">}&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>is essential to link our static library to the final compilation result from Kotlin. The value of &lt;code>rustLibAbsolutePath&lt;/code>
depends on current OS, as different systems support different types of static libraries.&lt;/p>
&lt;p>Additionally, we show how to add Kotlin/Native dependencies to some external libraries
with source set dependencies as&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;span class="lnt">2
&lt;/span>&lt;span class="lnt">3
&lt;/span>&lt;span class="lnt">4
&lt;/span>&lt;span class="lnt">5
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-kotlin" data-lang="kotlin">&lt;span class="line">&lt;span class="cl">&lt;span class="n">sourceSets&lt;/span> &lt;span class="p">{&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">getByName&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="s2">&amp;#34;nativeMain&amp;#34;&lt;/span>&lt;span class="p">).&lt;/span>&lt;span class="n">dependencies&lt;/span> &lt;span class="p">{&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">implementation&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="s2">&amp;#34;org.jetbrains.kotlinx:kotlinx-io-core:0.3.0&amp;#34;&lt;/span>&lt;span class="p">)&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="p">}&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="p">}&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>One last thing is including the definition of extra task named &lt;code>binaries&lt;/code> to commonize
the building process on all platforms. It calls the platform-specific task
that builds the release and debug binaries for host architecture.&lt;/p>
&lt;h2 id="compilation">Compilation
&lt;/h2>&lt;p>We can easily compile the final binary by calling gradle task&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-shell" data-lang="shell">&lt;span class="line">&lt;span class="cl">./gradlew binaries
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>which produces &lt;code>kotlin-tool&lt;/code> binary in a proper subdirectory of &lt;a class="link" href="https://github.com/avan1235/kotlin-native-rust-interop/tree/master/build/bin/" target="_blank" rel="noopener"
>bin&lt;/a> build results.&lt;/p>
&lt;p>We can use it to unzip some zip file, just by passing our file&amp;rsquo;s path as program argument.&lt;/p>
&lt;h2 id="conclusion">Conclusion
&lt;/h2>&lt;p>Configuring the Kotlin/Native project in a basic scenario might not be so straightforward
if we want to refer to some libraries built as a part of our project. Thanks to Gradle
flexibility we can call &lt;code>cargo&lt;/code>, build our Rust dependency and configure all the files
relatively to our root project. In these few steps we get some reference project configuration
that should work in most case and make our life simpler when we decide to build native binaries
with Kotlin and glue them with some external Rust libraries.&lt;/p></description></item><item><title>Latte Native compiler in Kotlin [#0]</title><link>https://procyk.in/post/latte-compiler-0/</link><pubDate>Tue, 13 Jun 2023 00:00:00 +0000</pubDate><guid>https://procyk.in/post/latte-compiler-0/</guid><description>&lt;img src="https://procyk.in/img/featured/featured-latte-compiler.jpg" alt="Featured image of post Latte Native compiler in Kotlin [#0]
" />&lt;h2 id="introduction">Introduction
&lt;/h2>&lt;p>For a few years now, every student of Computer Since at the University of Warsaw implements some kind of native x86 or
x64 compiler of &lt;a class="link" href="https://latte-lang.org/" target="_blank" rel="noopener"
>Latte&lt;/a> language to pass the Compilers&amp;rsquo; Construction and improve the skills and
the knowledge about how the compilers are built and what kinds of problems meet the designers of programming languages
in their careers. Most of the students implement the whole project in Haskell, which is the traditional choice for this
course. While some people try also other languages, like C++, Java or Rust, I finally decided to take advantage of
my Kotlin knowledge and use it in building some basic compiler. Thanks to this I could focus on the details of compilers'
construction and getting familiar with some crucial constructs that become really helpful when dealing with compilers.&lt;/p>
&lt;p>I hope that this series of posts may be helpful for some future students in passing their course with the best knowledge
gain, but I also would like to share my experience with some wider audience to show the others how the compilers may
be implemented and about what we should remember when using some popular compilers in our everyday work.&lt;/p>
&lt;h2 id="the-first-thoughts-to-share">The first thoughts to share
&lt;/h2>&lt;p>If somebody asks me, to give him a single advice before starting writing the compilers, I would start with the
sentence &amp;ldquo;select your favourite programming language that you feel comfortable programming any problem solution and
start reading about others approach to get most of their experience, as this part of computer science has is really
good founded&amp;rdquo;.&lt;/p>
&lt;p>The fun part is that I made a mistake, and chose some other great programming language before Kotlin to use in this
project — Rust.
It was a great opportunity for me to get familiar with the basics of the new programming language, but
the problem was that at some point this task became too hard to think about complex compiler construction and learning
some new aspects of the programming language in the same time.
So if you&amp;rsquo;re a student and still not sure if you
should take advantage of your programming skills in some language or try to learn new one during this course — I
strongly advise you focussing on the course topics that are fascinating and don&amp;rsquo;t bother yourself about some
programming language. It&amp;rsquo;s just a tool that you can learn anytime, so stay focused and try to learn a few new
things about compilers 😎.&lt;/p>
&lt;h2 id="whats-included-in-the-posts">What&amp;rsquo;s included in the posts
&lt;/h2>&lt;p>I share publicly my project at &lt;a class="link" href="https://github.com/avan1235/latte-compiler" target="_blank" rel="noopener"
>GitHub&lt;/a> just to show you what the whole
structure might look like and maybe to make you play with the Latte language if needed. The point of these posts
is to share the knowledge, some good internet sources and code samples that you may use when implementing your own
compiler. This project gives a lot of satisfaction for the developer, so even if you&amp;rsquo;re not a student, you can get a
chance to see what are the particular steps in building the compiler from scratch.&lt;/p>
&lt;p>There are a lot of topics that are discussed during the Compilers&amp;rsquo; Construction courses around the world, so
I won&amp;rsquo;t rewrite this content from scratch, but rather show some concrete examples of the implementation or give some
useful tips on concrete aspects of them.&lt;/p>
&lt;p>Don&amp;rsquo;t waste then more time on discussions and let&amp;rsquo;s begin our joint adventure through compilers&amp;rsquo; world 🤓.&lt;/p></description></item></channel></rss>