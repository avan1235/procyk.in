[{"content":"Introduction During the Day 2 the most important part was to quickly validate if the input report is valid. Let\u0026rsquo;s check out how Kotlin allows writing imperative code and combine it with functional approach easily.\nSolution Based on the task description, we can define the following function to check if a single report is valid.\n1 2 3 4 5 6 7 8 9 10 11 fun isReportValid(report: List\u0026lt;Long\u0026gt;): Boolean { val increase = report[1] \u0026gt;= report[0] for (idx in report.indices) { if (idx == 0) continue if (increase \u0026amp;\u0026amp; report[idx] \u0026lt;= report[idx - 1]) return false if (!increase \u0026amp;\u0026amp; report[idx] \u0026gt;= report[idx - 1]) return false if (abs(report[idx] - report[idx - 1]) \u0026lt; 1) return false if (abs(report[idx] - report[idx - 1]) \u0026gt; 3) return false } return true } This approach is so straightforward and readable that I personally don\u0026rsquo;t want to find any functional alternative to it. Let\u0026rsquo;s notice, it can be read line by line and while self-explaining itself at the same time:\ncheck if the report is increasing or decreasing iterate over all elements of the report, skipping the first one for each element, compare it with the previous one and check if any condition for validity is violated: if the whole report is increasing, it must increase for current two elements if the whole report is decreasing, it must decrease for current two elements the distance between two next elements must not be smaller than 1 nor greater than 3 Using such a helper function, we can count the valid reports for Part One with standard library function\n1 reports.count(::isReportValid) During Part Two we can notice that the input reports are quite short. So for each of them we can try generating the versions of it with one element removed and check if any of them is a valid report.\nThis can be achieved with simple utility function like\n1 2 3 4 5 private fun \u0026lt;R\u0026gt; List\u0026lt;R\u0026gt;.withEachElementRemoved(): Sequence\u0026lt;List\u0026lt;R\u0026gt;\u0026gt; = sequence { for (removedIdx in indices) { yield(filterIndexed { idx, _ -\u0026gt; idx != removedIdx }) } } that makes use of the Kotlin Sequence\u0026lt;out T\u0026gt; type and provide the following versions of a caller list lazily.\nThanks to this behavior, we can avoid generating all versions of the report if we\u0026rsquo;ve already found a valid version of the report.\n1 2 3 reports.count { report -\u0026gt; isReportValid(report) || report.withEachElementRemoved().any(::isReportValid) } ","date":"2024-12-02T00:00:00Z","image":"https://procyk.in/post/advent-of-code-2024-2/featured_hu13385033237855786311.jpg","permalink":"https://procyk.in/post/advent-of-code-2024-2/","title":"Advent of Code 2024 in Kotlin - Day 2"},{"content":"Introduction We start with Day 1 for which the actual problem is usually about transforming input data quickly, using the available library functions.\nSolution After reading input data line by line, we can easily get the input like\n1 2 3 4 5 6 7 8 val data = listOf( listOf(3, 4), listOf(4, 3), listOf(2, 5), listOf(1, 3), listOf(3, 9), listOf(3, 3), ) while what is needed to calculate actual answer is data in format like\n1 2 3 4 5 val data = listOf( listOf(3, 4, 2, 1, 3, 3), listOf(4, 3, 5, 3, 9, 3), ) val (fst, snd) = data To achieve that, we can make use of the created utility function, which treats such a list of lists as a matrix and does the transpose operation on it. This operation is about changing the indices of columns with the indices of rows, by simply remapping the data to new structure.\n1 2 3 4 5 fun \u0026lt;T\u0026gt; List\u0026lt;List\u0026lt;T\u0026gt;\u0026gt;.transpose(): List\u0026lt;List\u0026lt;T\u0026gt;\u0026gt; { val n = map { it.size }.toSet().singleOrNull() ?: throw IllegalArgumentException(\u0026#34;Invalid data to transpose: $this\u0026#34;) return List(n) { y -\u0026gt; List(size) { x -\u0026gt; this[x][y] } } } Having data in such formats, we can easily provide answers for both parts of Day 1.\nPart One sums the absolute distances between pairs of numbers from each of the lists with the standard library utility functions\n1 fst.sorted().zip(snd.sorted()).sumOf { (a, b) -\u0026gt; abs(a - b) } while Part Two is about counting the occurrences of each number in the second list and then making use of it to calculate the expected score with simple call to sumOf { ... }.\nIn the same time we can make use here of the DefaultMap\u0026lt;K, V\u0026gt; defined in our utilities\u0026rsquo; file. Thanks to that approach, we can get the 0 count for each number that doesn\u0026rsquo;t occur in the second list and get the answer with simple\n1 2 val sndEachCount = snd.groupingBy { it }.eachCount().toDefaultMap(0) fst.sumOf { sndEachCount[it] * it } ","date":"2024-12-01T00:00:00Z","image":"https://procyk.in/post/advent-of-code-2024-1/featured_hu14325194803918440608.jpg","permalink":"https://procyk.in/post/advent-of-code-2024-1/","title":"Advent of Code 2024 in Kotlin - Day 1"},{"content":"Kotlin/Native \u0026amp; Rust interoperability Let\u0026rsquo;s start with forking the project on GitHub and cloning it to your device to try it yourself.\nMain goal We want to build an executable in Kotlin to use the language capabilities and our knowledge, but at the same time deliver fully independent of JVM solution, which can be as small as few megabytes.\nHowever, not every functionality can be easily handled in Kotlin, so sometimes it\u0026rsquo;s just more convenient to prepare some external library, expose its symbols with C ABI and call them in expected places in Kotlin. We would prefer to build a static library, which can then be statically linked to the final executable, to make sure that the end user needs only a single binary to run our program.\nIn our specific example, we see how to write a CLI tool in Kotlin/Native, but prepare an external library in Rust. The external library is responsible for unzipping the given file to a specific location. In Kotlin, we handle the rest of business logic, which (for the sake of simplicity) is just proper handling of program arguments and deleting some files, to see how the Kotlin/Native libraries can be used.\nProject configuration Let\u0026rsquo;s start with having look at the project structure that\u0026rsquo;s worth explaining what files and directories are responsible for which part of the project configuration.\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 â”œâ”€â”€ build.gradle.kts â”œâ”€â”€ gradle â”‚Â â””â”€â”€ wrapper â”‚Â â”œâ”€â”€ gradle-wrapper.jar â”‚Â â””â”€â”€ gradle-wrapper.properties â”œâ”€â”€ gradle.properties â”œâ”€â”€ gradlew â”œâ”€â”€ gradlew.bat â”œâ”€â”€ README.md â”œâ”€â”€ rust_lib â”‚Â â”œâ”€â”€ build.rs â”‚Â â”œâ”€â”€ Cargo.toml â”‚Â â””â”€â”€ src â”‚Â â””â”€â”€ lib.rs â”œâ”€â”€ settings.gradle.kts â””â”€â”€ src â”œâ”€â”€ nativeInterop â”‚Â â””â”€â”€ cinterop â”‚Â â””â”€â”€ librust_lib.def â””â”€â”€ nativeMain â””â”€â”€ kotlin â”œâ”€â”€ Main.kt â””â”€â”€ ReportedError.kt Rust library First of all, we include the rust_lib directory in our root. It contains the Rust project exporting static library. Its Cargo.ml explicitly says that the build result is staticlib, for which release profile has multiple final binary size oriented optimizations enabled. It also declares two dependencies:\nzip being our business-specific dependency that simplifies the implementation of unzipping files cbindgen being must-have dependency, which is responsible for exporting the .h header file based on the definitions from our library. You can find a proper file rust_lib.h after executing buildRustLib Gradle task. Additionally, in build.rs we include actual logics responsible for this process. The lib.rs file contains, on the other hand, the actual definition of our exported library. We need to specify all the functions\u0026rsquo; symbols as pub extern \u0026quot;C\u0026quot; and add the #[no_mangle] macro to make them accessible via C ABI, as well as it\u0026rsquo;s crucial to use a proper type for function arguments and returned value â€“ they need to be compatible with the ones that C language would produce.\nThat implies the proper conversion of arguments, to make them friendly to Rust. In our case we work with string values, which are passed as char *out_path. It\u0026rsquo;s important to use unsafe { CStr::from_ptr(chars) }; to convert them to \u0026amp;str â€“ notice that using unsafe { CString::from_raw(chars) }; is an incorrect approach as it leads to invalid free operation (we can find in CString::from_raw documentation that If you need to borrow a string that was allocated by foreign code, use CStr.)\nThe final static library file, produced from our rust_lib, will be available in release directory, and we\u0026rsquo;re going to use it while compiling final binary, to find the symbols defined in header file.\nGradle project We configure our root project with Gradle, using Kotlin Multiplatform Plugin to enable compilation to native targets. The main configuration file build.gradle.kts has a few, quite interesting definitions, that we\u0026rsquo;ve used to achieve our goal of building independent binary.\nWe use DefaultNativePlatform helper to read current host OS and architecture and configure the compilation for our platform. Inside the kotlin { ... } block we configure the native target to host and then configure it inside the target { ... } block. There are two parts of the configuration that play the main role in our final result.\nThe first part\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 compilations.getByName(\u0026#34;main\u0026#34;).cinterops { create(\u0026#34;librust_lib\u0026#34;) { val buildRustLib by tasks.creating { exec { executable = cargoAbsolutePath args( \u0026#34;build\u0026#34;, \u0026#34;--manifest-path\u0026#34;, projectFile(\u0026#34;rust_lib/Cargo.toml\u0026#34;), \u0026#34;--package\u0026#34;, \u0026#34;rust_lib\u0026#34;, \u0026#34;--lib\u0026#34;, \u0026#34;--release\u0026#34; ) } } tasks.getByName(interopProcessingTaskName) { dependsOn(buildRustLib) } header(projectFile(\u0026#34;rust_lib/target/rust_lib.h\u0026#34;)) } } is responsible for interoperability between Kotlin and C symbols. We create the librust_lib cinterop and configure the header location manually with projectFile function to get absolute path of the header, having the current location of project directory. Moreover, we add extra task named buildRustLib, which calls cargo command to build our Rust library before the cinterop task is executed. To make sure we have our header file available, we explicitly define the dependency on interopProcessingTaskName. It\u0026rsquo;s worth mentioning here, that we include empty librust_lib.def file in our project. It\u0026rsquo;s required by project structure, as described in the official documentation example. However, we want to define the required header relatively to project directory, and it seems that working and nice approach is to configure it directly in our build script.\nThe second step â€” configuring final executable with\n1 2 3 4 5 binaries.executable { entryPoint = \u0026#34;main\u0026#34; baseName = \u0026#34;kotlin-tool\u0026#34; linkerOpts += rustLibAbsolutePath } is essential to link our static library to the final compilation result from Kotlin. The value of rustLibAbsolutePath depends on current OS, as different systems support different types of static libraries.\nAdditionally, we show how to add Kotlin/Native dependencies to some external libraries with source set dependencies as\n1 2 3 4 5 sourceSets { getByName(\u0026#34;nativeMain\u0026#34;).dependencies { implementation(\u0026#34;org.jetbrains.kotlinx:kotlinx-io-core:0.3.0\u0026#34;) } } One last thing is including the definition of extra task named binaries to commonize the building process on all platforms. It calls the platform-specific task that builds the release and debug binaries for host architecture.\nCompilation We can easily compile the final binary by calling gradle task\n1 ./gradlew binaries which produces kotlin-tool binary in a proper subdirectory of bin build results.\nWe can use it to unzip some zip file, just by passing our file\u0026rsquo;s path as program argument.\nConclusion Configuring the Kotlin/Native project in a basic scenario might not be so straightforward if we want to refer to some libraries built as a part of our project. Thanks to Gradle flexibility we can call cargo, build our Rust dependency and configure all the files relatively to our root project. In these few steps we get some reference project configuration that should work in most case and make our life simpler when we decide to build native binaries with Kotlin and glue them with some external Rust libraries.\n","date":"2023-11-05T00:00:00Z","image":"https://procyk.in/img/featured/featured-kotlin-rust.jpg","permalink":"https://procyk.in/post/kotlin-native-rust-interop/","title":"Kotlin/Native \u0026 Rust interoperability\n"},{"content":"Introduction Usually, when working with some programming languages, we deal with more than a single source file. That\u0026rsquo;s when the tools responsible for compiling every source file and caching the old compilations' results are really helpful. They allow us to forget about the raw calls to compilers and focus on coding. We\u0026rsquo;re going to explore the two examples of such tools for Kotlin and Swift and see how the simplest configuration with them looks like.\nProject structure Project structure is what usually defines the relative location of source files and the definition of their dependencies in projects. In the case of Kotlin and Swift we can have some \u0026ldquo;standardized\u0026rdquo; directories structure with certain files required for the project to be compilable. Let\u0026rsquo;s see how they works and what\u0026rsquo;re the minimal examples for each of them.\nSwift project structure We\u0026rsquo;re going to work with project managed by Swift Package Manager, which is a tool available from Swift 3.0. The alternatives are old CocoaPods and Carthage, which existed before SPM.\nSPM organizes code in modules, which can be seen as namespaces that enforce the access control in code. The source files with their Package.swift manifest file are called package. Package can have multiple targets, which is a library or an executable. We can see that the manifest file is defined in Swift language which gives us more possibilities with the knowledge of this language. We can define the dependencies in the script by specifying the location of their sources. Script needs to start with special line with the definition of version for swift-tools - you can get unreadable errors after removing this line so watch out!\nHere is a sample configuration file which we\u0026rsquo;ll use to start simple HTTP server. Let\u0026rsquo;s notice that the dependencies are mentioned here twice - first we got the list of them, then we assign specific dependencies to concrete targets.\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 // swift-tools-version: 5.8 import PackageDescription let package = Package( name: \u0026#34;swift-playground\u0026#34;, dependencies: [ .package( url: \u0026#34;https://github.com/vapor/vapor.git\u0026#34;, branch: \u0026#34;main\u0026#34;), ], targets: [ .executableTarget( name: \u0026#34;swift-playground\u0026#34;, dependencies: [ .product(name: \u0026#34;Vapor\u0026#34;, package: \u0026#34;vapor\u0026#34;), ], path: \u0026#34;Sources\u0026#34;), ] ) It\u0026rsquo;s worth noticing how the code structure in such SPM looks like - the manifest file exists in root directory while the source files are placed in some directory defined in script.\nTo specify the entrypoint of our executable we have two options:\nuse special @main annotation on struct with static main method name the file with entrypoint main.swift and then place the instructions top-file We can then try deploying our HTTP server base with a few top-file instructions based on the Vapor library documentation.\n1 2 3 4 5 6 7 8 9 10 11 12 13 import Vapor let arguments = [\u0026#34;vapor\u0026#34;, \u0026#34;serve\u0026#34;, \u0026#34;--port\u0026#34;, \u0026#34;1234\u0026#34;] let app = try Application(.detect(arguments: arguments)) defer { app.shutdown() } app.get(\u0026#34;\u0026#34;) { req in \u0026#34;Hello World!\u0026#34; } try app.run() This small piece of code shows a huge power of Swift and its constructs and allows to deploy a HTTP server with a few lines of code - wow! It\u0026rsquo;s enough to call swift run command or run the build configuration created by Swift plugin in CLion.\nYou can find the running example at this commit.\nPsss.. We\u0026rsquo;re going to discuss these language features in future posts, so stay tuned!\nKotlin project structure The Kotlin project uses Gradle which is not limited to Kotlin and Java projects but they are its main targets. It allows to define hierarchical structure of project with tasks able to run arbitrary Kotlin code. It supports applying different plugins which can modify the project.\nTo compile Kotlin project with Gradle, we don\u0026rsquo;t even need to install Kotlin compiler as we\u0026rsquo;ve seen in the previous post. Gradle, thanks to applying kotlin(\u0026quot;jvm\u0026quot;) plugin, can manage downloading Kotlin compiler, and thanks to applying application plugin it can create and run a JVM application with proper dependencies\u0026rsquo; management.\nThe latest configuration files uses Kotlin language, so once again we get all the features of the language when building the project! The minimal configuration to run the HTTP server in Kotlin might look like in the following way\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 plugins { kotlin(\u0026#34;jvm\u0026#34;) version \u0026#34;1.8.21\u0026#34; application } repositories { mavenCentral() } dependencies { implementation(\u0026#34;io.ktor:ktor-server-core-jvm:2.3.2\u0026#34;) implementation(\u0026#34;io.ktor:ktor-server-netty-jvm:2.3.2\u0026#34;) } application { mainClass.set(\u0026#34;MainKt\u0026#34;) } It requires manual specification of the class that contains the entrypoint for the JVM - let\u0026rsquo;s notive the name MainKt was give, as this is the name of the class generated by Kotlin for the top-file main function.\nWe can notice that the project contains also other files that build its structure:\ngradle.properties file can contain extra definitions in key-value format gradlew files with the gradle directory allows to run Gradle without installing it on machine and depending on local version - it\u0026rsquo;s a portable version of Gradle that can be submitted to the repository and redistributed and requires only JVM to work settings.gradle.kts file defines the top parent of the hierarchical project structure So our first try to deploy the same HTTP server as we did with Swift would use the mentioned build.gradle.kts and have the following Main.kt file\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 import io.ktor.server.application.* import io.ktor.server.engine.* import io.ktor.server.netty.* import io.ktor.server.response.* import io.ktor.server.routing.* fun main() { embeddedServer(Netty, port = 1234) { routing { get (\u0026#34;/\u0026#34;) { call.respondText(\u0026#34;Hello World!\u0026#34;) } } }.start(wait = true) } We can notice that Kotlin also allows using just a small piece of code to start a huge machine such as HTTP server. It seems more declarative in this case, as everything is wrapped in single structure describing our intention.\nYou can find the Kotlin sample in this commit.\nSummary Both languages uses their power to define builds which gives the programmers more flexibility when defining the project structure. They aim to provide a declarative way of defining a project with similar concepts of splitting them into libraries which can be reused as dependencies. Both languages allow to define a sample application with a few lines which show a huge powers of these languages. We\u0026rsquo;re going to dive deep into the in the future posts, so stay tuned!\n","date":"2023-06-29T00:00:00Z","image":"https://procyk.in/img/featured/featured-kotlin-swift.jpg","permalink":"https://procyk.in/post/kotlin-swift-1/","title":"Kotlin vs Swift [#1]\n"},{"content":"Introduction There are a few outstanding programming languages which have a huge impact on current state of the market. Two of them, especially important in context of mobile development are Kotlin by JetBrains and Swift by Apple. In this series of posts we\u0026rsquo;ll focus on comparison of what these two languages have to offer, parts have in common and what each of them can learn from the other. The purpose of this series is to get deep understanding of these languages and their compilers so stay there if that\u0026rsquo;s what you\u0026rsquo;re interested in.\nWork environment As I\u0026rsquo;m most fluent with JetBrains IDEs, I\u0026rsquo;ll present how to start working with these languages using their tools. The benefit of this approach is that I can use my Debian machine to compile Kotlin as well as Swift and have an intelligent IDE with code understanding for both languages.\nKotlin environment Kotlin compiler In case of Kotlin development we can use the known Gradle wrapper script that is responsible for downloading all dependencies, including Kotlin compiler by using proper plugin in script. You can find standalone version of Kotlin compiler on GitHub, but the easiest approach is to work with Gradle model.\nKotlin IDE Using IntelliJ IDEA by JetBrains is the easiest way to start with creating gradle project. However, it might bring some surprises as well. From my perspective, it\u0026rsquo;s important to set up the project structure properly. So to generate a Kotlin Gradle project, we can use available wizard, but we need to take care of proper selection of JDK when using Gradle. It turns out that for now Gradle doesn\u0026rsquo;t work with JDK 21, which might be the only one available on your machine after installing IDE. The cool part is that you can download the selected JDK directly from IntelliJ. It\u0026rsquo;s really helpful to don\u0026rsquo;t bother about all the paths and download sources for these SDKs. Personally, I like Amazon Corretto 11 JDK which will be definitely enough for this series of posts. After downloading it, we can create our project with a few clicks in wizard.\nSwift environment Swift compiler To work with Swift on my linux (Debian 12) machine, I download latest release version from Download Swift and install the dependencies. I use the Ubuntu 22.04 version as it corresponds to Debian Bookworm the most and seems to be working pretty fine so far.\nThe whole process starts with installing the latest packages available for Debian Bookworm with\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 sudo apt install \\ binutils \\ git \\ gnupg2 \\ libc6-dev \\ libcurl4-openssl-dev \\ libedit2 \\ libgcc-11-dev \\ libpython3.11 \\ libsqlite3-0 \\ libstdc++-11-dev \\ libxml2-dev \\ libz3-dev \\ pkg-config \\ tzdata \\ unzip \\ zlib1g-dev The next step is to unpack the downloaded Swift compiler with e.g.\n1 tar -xzf swift-5.8.1-RELEASE-ubuntu22.04.tar.gz and then move it to opt with\n1 sudo mv swift-5.8.1-RELEASE-ubuntu22.04 /opt/swift and finally add the installation path to PATH variable. You can do it by appending extra line to ~/.bashrc\n1 export PATH=$PATH:/opt/swift/usr/bin and apply changes with\n1 source ~/.bashrc If everything went well, calling\n1 swift -version should print our Swift compiler version.\nSwift IDE The default option for most of the developers is XCode, only because it\u0026rsquo;s the easiest and the most straightforward option on MacOS. It\u0026rsquo;s really convenient to do Swift development on Apple devices but we need to highlight here that Swift is an open-source language and can be compiled on many platforms.\nI personally like using CLion by JetBrains with Swift plugin. One of the reasons is familiarity with the whole family of products, the other is my own contribution to functionalities of the plugin from my internships at JetBrains. It\u0026rsquo;s the only plugin that is not only based on Source-Kit (i.e. LSP implementation for Swift) and provides support for Swift in JetBrains products.\nTo configure plugin after installing, it\u0026rsquo;s enough to set Swift toolchain path under Build, Execution, Deployment \u0026gt; Swift. Then we can start with creating new project being executable Swift package.\nSummary According to this post, one can assume that setting up Kotlin is much easier than dealing with Swift. But we need to remember about the specific environment that we work in. Although Swift is designed to be used on MacOS, you can compile with it on Linux and Windows machines as well. In case of Kotlin, we\u0026rsquo;re in JVM world which is universal and doesn\u0026rsquo;t depend a lot on operating system.\n","date":"2023-06-26T00:00:00Z","image":"https://procyk.in/img/featured/featured-kotlin-swift.jpg","permalink":"https://procyk.in/post/kotlin-swift-0/","title":"Kotlin vs Swift [#0]\n"},{"content":"Introduction For a few years now, every student of Computer Since at the University of Warsaw implements some kind of native x86 or x64 compiler of Latte language to pass the Compilers\u0026rsquo; Construction and improve the skills and the knowledge about how the compilers are built and what kinds of problems meet the designers of programming languages in their careers. Most of the students implement the whole project in Haskell, which is the traditional choice for this course. While some people try also other languages, like C++, Java or Rust, I finally decided to take advantage of my Kotlin knowledge and use it in building some basic compiler. Thanks to this I could focus on the details of compilers' construction and getting familiar with some crucial constructs that become really helpful when dealing with compilers.\nI hope that this series of posts may be helpful for some future students in passing their course with the best knowledge gain, but I also would like to share my experience with some wider audience to show the others how the compilers may be implemented and about what we should remember when using some popular compilers in our everyday work.\nThe first thoughts to share If somebody asks me, to give him a single advice before starting writing the compilers, I would start with the sentence \u0026ldquo;select your favourite programming language that you feel comfortable programming any problem solution and start reading about others approach to get most of their experience, as this part of computer science has is really good founded\u0026rdquo;.\nThe fun part is that I made a mistake, and chose some other great programming language before Kotlin to use in this project â€” Rust. It was a great opportunity for me to get familiar with the basics of the new programming language, but the problem was that at some point this task became too hard to think about complex compiler construction and learning some new aspects of the programming language in the same time. So if you\u0026rsquo;re a student and still not sure if you should take advantage of your programming skills in some language or try to learn new one during this course â€” I strongly advise you focussing on the course topics that are fascinating and don\u0026rsquo;t bother yourself about some programming language. It\u0026rsquo;s just a tool that you can learn anytime, so stay focused and try to learn a few new things about compilers ðŸ˜Ž.\nWhat\u0026rsquo;s included in the posts I share publicly my project at GitHub just to show you what the whole structure might look like and maybe to make you play with the Latte language if needed. The point of these posts is to share the knowledge, some good internet sources and code samples that you may use when implementing your own compiler. This project gives a lot of satisfaction for the developer, so even if you\u0026rsquo;re not a student, you can get a chance to see what are the particular steps in building the compiler from scratch.\nThere are a lot of topics that are discussed during the Compilers\u0026rsquo; Construction courses around the world, so I won\u0026rsquo;t rewrite this content from scratch, but rather show some concrete examples of the implementation or give some useful tips on concrete aspects of them.\nDon\u0026rsquo;t waste then more time on discussions and let\u0026rsquo;s begin our joint adventure through compilers\u0026rsquo; world ðŸ¤“.\n","date":"2023-06-13T00:00:00Z","image":"https://procyk.in/img/featured/featured-latte-compiler.jpg","permalink":"https://procyk.in/post/latte-compiler-0/","title":"Latte Native compiler in Kotlin [#0]\n"},{"content":"Presentation I\u0026rsquo;ve prepared some academic presentation about coroutines on the example of Kotlin, its construction and details and usage in small application. Enjoy it and let me know what do you think about this way of presenting this topic for some wider audience ðŸ˜‰.\nPrevious / Next Download ","date":"2023-03-23T00:00:00Z","image":"https://procyk.in/post/kotlin-coroutines/featured_hu17703046906804694497.jpg","permalink":"https://procyk.in/post/kotlin-coroutines/","title":"Deep Dive Into Coroutines Presentation"},{"content":"Introduction I was somehow afraid, that Day 25 will start with some really hard problem, as it was the last day and the previous ones were probably one of the hardest days in this time. Happily, we got a great present and the whole problem with proper representation in data was quite simple and didn\u0026rsquo;t even have a second part, so it didn\u0026rsquo;t take a lot of time. Let\u0026rsquo;s see how we can see this kind of problems to efficiently manage the transformed data in readable way.\nSolution The approach used in this day is quite similar to some previous days, where instead of having some array of sea fields or the map from field to the type of the field, we store the sets of the fields of each type, as there are only three of them east, south and empty.\nWith the sets\u0026rsquo; representation, all moves transformations are really easy, as they operate on some current sets' values and don\u0026rsquo;t require taking extra care about some intermediate state of the transformation. We could even abstract some kind of partial step of transformation as separate function moveGroup that for some current set of empty places and of the places of to move from, was able to generate the pair of these transformed sets with just a few lines of code.\nDay25.kt 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 object Day25 : AdventDay() { override fun solve() { val data = reads\u0026lt;String\u0026gt;() ?: return val sea = data.toSea() generateSequence(sea) { it.step().takeIf { update -\u0026gt; update != it } }.count().printIt() } } private fun List\u0026lt;String\u0026gt;.toSea(): Sea { val east = HashSet\u0026lt;Region\u0026gt;() val south = HashSet\u0026lt;Region\u0026gt;() val empty = HashSet\u0026lt;Region\u0026gt;() for ((y, line) in withIndex()) for ((x, c) in line.withIndex()) when (c) { \u0026#39;.\u0026#39; -\u0026gt; empty \u0026#39;\u0026gt;\u0026#39; -\u0026gt; east \u0026#39;v\u0026#39; -\u0026gt; south else -\u0026gt; error(\u0026#34;Unknown input char: $c\u0026#34;) } += Region(x, y) return Sea(east, south, empty, first().length, size) } private data class Region(val x: Int, val y: Int) private data class Sea( val east: Set\u0026lt;Region\u0026gt;, val south: Set\u0026lt;Region\u0026gt;, val empty: Set\u0026lt;Region\u0026gt;, val xSize: Int, val ySize: Int, ) { fun step(): Sea { val (currEmpty, east) = moveGroup(empty, east) { east() } val (finalEmpty, south) = moveGroup(currEmpty, south) { south() } return copy(east = east, south = south, empty = finalEmpty) } private fun moveGroup(currEmpty: Set\u0026lt;Region\u0026gt;, moving: Set\u0026lt;Region\u0026gt;, move: Region.() -\u0026gt; Region) = HashSet(currEmpty).let { empty -\u0026gt; empty to moving.mapTo(HashSet()) { region -\u0026gt; region.move().takeIf { it in currEmpty } ?.also { empty -= it } ?.also { empty += region } ?: region } } private fun Region.east() = Region((x + 1) % xSize, y) private fun Region.south() = Region(x, (y + 1) % ySize) } Extra notes To implement the moveGroup function, we used the lambda with receiver parameter move: Region.() -\u0026gt; Region to simulate the movement of given field. In Kotlin, we can use this kind of definitions, to get a better syntax look and better experience, when using these functions. That\u0026rsquo;s because they don\u0026rsquo;t need specifying the lambda argument, as it is a this object, for which we can call some method, e.g. in our code we just write\n1 moveGroup(empty, east) { east() } and the east method is called on some default this object in the specified context. We defined some extension functions for these moves and located them in the Sea class to take advantage of the Sea context and check for the size of the sea in the implementation of the method called on Region.\n","date":"2021-12-25T00:00:00Z","image":"https://procyk.in/post/advent-of-code-2021-25/featured_hu11497596244032219998.jpg","permalink":"https://procyk.in/post/advent-of-code-2021-25/","title":"Advent of Code 2021 in Kotlin - Day 25"},{"content":"Introduction The Day 24 problem was not a typical problem. It includes reverse engineering some pseudo-assembly code to predict the output of program. Let\u0026rsquo;s see how we can deal with some similar problems and how to use programming languages when solving such problems.\nSolution As in most of the \u0026ldquo;exploitation\u0026rdquo; problems, we need to come up with some smart observation to solve the problem What I\u0026rsquo;ve found is the structure of the assembly code, i.e. the fact that it\u0026rsquo;s built with 14 blocks (each for each input digit) with the same structure\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 inp w mul x 0 add x z mod x 26 // may have different value div z 1 // may have different value add x 12 // may have different value eql x w eql x 0 mul y 0 add y 25 // may have different value mul y x add y 1 // may have different value mul z y mul y 0 add y w add y 15 // may have different value mul y x add z y and when we see how it works, we can notice that only w and z initial values are important because x and y are zeroed before usage of them.\nSo we found some 14 blocks for checking each of the digit of the final code, that transform the z value and read the next digit to w. What we have to find is such a combination of digits for which, after all transformations, we would end up with the z equal to 0.\nWe can try to solve this kind of problems by reverse engineering these simple gadgets and remembering what are their outputs for every of the combination of given digit and value of z. So in reverseDigitMappings we try to run every of these gadgets for every digit from 1..9 and a huge number of different z variables in initial state. It\u0026rsquo;s worth mentioning here that the selected range for z was fixed to get a repeatable answer when decreasing tested ranges, so it may require increasing for some specific inputs.\nHaving these mapping we can start actual reversing the answer. So we look at the computed values and read from them the set of pairs of input digit and z value, for which after transformation of 14th gadget we get 0 in z. For these values we also need to solve similar problem, be recursively checking next digits backwards. We do this with recursive function go which is defined as recursive because it can have at most 15 levels of nesting, and it\u0026rsquo;s the easiest way of remembering the list of digits that we\u0026rsquo;ve tried along our current path of searching.\nTo solve both parts of the problem with the same code, we define findDigits with Comparator\u0026lt;Long\u0026gt; parameter, so we can select an order of searching through the digits in each step. In this way we\u0026rsquo;re able to find the solution in a few seconds, where most of the time is used for generating the reverse mappings, so it can be reduced because the gadgets blocks are repeating in input and some computations are not needed at all (but we leave them for simpler code).\nDay24.kt 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 object Day24 : AdventDay() { override fun solve() { val data = reads\u0026lt;String\u0026gt;() ?: return val instr = data.map { it.toInstr() } val reverseDigits = instr.reverseDigitsMappings() reverseDigits.findDigits(compareByDescending { it }).printIt() reverseDigits.findDigits(compareBy { it }).printIt() } } private fun String.toInstr(): Instr { val parts = split(\u0026#34; \u0026#34;) return when { parts.size == 2 \u0026amp;\u0026amp; parts[0] == \u0026#34;inp\u0026#34; -\u0026gt; Inp(parts[1]) parts.size == 3 -\u0026gt; BinOp(parts[1], Op.valueOf(parts[0].uppercase()), parts[2].toRight()) else -\u0026gt; error(\u0026#34;Unknown command type: $this\u0026#34;) } } private fun String.toRight() = try { Num(toLong()) } catch (_: Exception) { Var(this) } private class ReverseDigits(private val mapping: List\u0026lt;LazyDefaultMap\u0026lt;Long, MutableSet\u0026lt;StartingWith\u0026gt;\u0026gt;\u0026gt;) { data class StartingWith(val z: Long, val digit: Long) fun findDigits(digitsComparator: Comparator\u0026lt;Long\u0026gt;): Long? { fun go(digitIdx: Int, forZ: Long, acc: List\u0026lt;Long\u0026gt;): List\u0026lt;Long\u0026gt;? = if (digitIdx \u0026lt; 0) acc.reversed() else reverseRegState(digitIdx, forZ) .sortedWith { l, r -\u0026gt; digitsComparator.compare(l.digit, r.digit) } .firstNotNullOfOrNull { go(digitIdx - 1, it.z, acc + it.digit) } val digits = go(digitIdx = mapping.size - 1, forZ = 0, acc = listOf()) return digits?.joinToString(\u0026#34;\u0026#34;)?.toLongOrNull() } private fun reverseRegState(idx: Int, value: Long): Set\u0026lt;StartingWith\u0026gt; = if (idx in mapping.indices) mapping[idx][value] else emptySet() } private fun List\u0026lt;Instr\u0026gt;.reverseDigitsMappings(searchMax: Long = 1 shl 15): ReverseDigits = groupSeparatedBy(separator = { it is Inp }, includeSeparator = true) { instr -\u0026gt; LazyDefaultMap\u0026lt;Long, MutableSet\u0026lt;ReverseDigits.StartingWith\u0026gt;\u0026gt;(::mutableSetOf).also { finishedWith -\u0026gt; for (forZ in 0L..searchMax) for (forDigit in 1L..9L) ALU(forDigit, withState = mapOf(\u0026#34;z\u0026#34; to forZ)).apply { run(instr) } .registers[\u0026#34;z\u0026#34;].let { finishedWith[it].add(ReverseDigits.StartingWith(forZ, forDigit)) } } }.let { ReverseDigits(it) } private typealias VarName = String private typealias Left = VarName private sealed interface Right private data class Var(val name: VarName) : Right private data class Num(val value: Long) : Right private enum class Op(val action: (Long, Long) -\u0026gt; Long) { ADD(Long::plus), MUL(Long::times), DIV(Long::div), MOD(Long::mod), EQL({ l, r -\u0026gt; if (l == r) 1 else 0 }) } private sealed interface Instr private data class Inp(val toVar: VarName) : Instr private data class BinOp(val left: Left, val op: Op, val right: Right) : Instr private class ALU(vararg val input: Long, withState: Map\u0026lt;VarName, Long\u0026gt; = emptyMap()) { val registers = withState.toDefaultMap(0) private var inputIdx = 0 fun run(instr: Iterable\u0026lt;Instr\u0026gt;) = instr.forEach { process(it) } private fun process(instr: Instr) = when (instr) { is Inp -\u0026gt; { registers[instr.toVar] = input[inputIdx] inputIdx += 1 } is BinOp -\u0026gt; when (instr.right) { is Num -\u0026gt; instr.right.value is Var -\u0026gt; registers[instr.right.name] }.let { rVal -\u0026gt; registers[instr.left] = instr.op.action(registers[instr.left], rVal) } } } Extra notes We\u0026rsquo;ve used in our solution some use of sealed interface as well as the enum class so it\u0026rsquo;s worth mentioning what\u0026rsquo;s the actual difference between them and where we should use every of them.\nSo the enum classes in Kotlin are similar to the enums from C-like languages as they are some kind of fixed, singleton objects of specified type that hold some type information. Then can of course also have extra methods and override the others, but this kind of code becomes quite hard to read. From my experience, they should be used when some kind of label is needed, so we could take some specific actions in different contexts for the labels.\nIn case of the sealed interfaces we get somehow similar possibilities, but the classes that implement this kind of interfaces are intended to hold some values. In Kotlin, the compiler is pretty smart, so we can use when statements to check for type of some object and use the fields of some checked class in the case body, as the checked value is automatically cast to checked type. Let\u0026rsquo;s take a look e.g. at the ALU::process method that uses the instr fields and they are quite different in different cases of when.\n","date":"2021-12-24T00:00:00Z","image":"https://procyk.in/post/advent-of-code-2021-24/featured_hu5018747435172119594.jpg","permalink":"https://procyk.in/post/advent-of-code-2021-24/","title":"Advent of Code 2021 in Kotlin - Day 24"},{"content":"Introduction In the Day 23 problem we have to face up two hard parts. The first includes reading data from really concise input and interpreting it, while the second is about searching in some space of states that need to be generated on the fly. Let\u0026rsquo;s see how we can deal with these problems in Kotlin.\nSolution We use the input map to get multiple information from it. The first (obvious one) is the location of each amphipod on the map. We store them as the map from location F to the amphipod type. What we need more to properly compute the state changes, are the positions to which the amphipod can move in the specified move. To safe time in computation, we calculate some set of spaces and map collides. The spaces keeps the coordinates of all fields, that can be occupied by an amphipod. The collides map stores the information about the fields on the way from one field on map to another and the number of steps required to move between these places. We calculate this map by doing some path traversal in scanPaths function, that is capable of searching the graph of moves with remembering the paths\u0026rsquo; statistics in path.\nHaving some MapState we can think of generating the next states from the given state. We implement this in MapState::reachable by taking into account all the rules described in task. For example, we expressed the rule of moving only from hallway to room or from room to hallway by writing\n1 if (!(from.isHallway xor moveTo.isHallway)) continue so we skip the situations in which we would move from hallway to hallway and from room to room.\nHaving these functions implemented, we can start searching for the smallest energy needed to get to final state of the map. We use the Dijkstra algorithm to solve this problem, but we have to take care of the states that we generate from current, not final state, as in the current moment of findMinEnergy we know only some part of all possible states (that we generated from the previously visited states).\nDay23.kt 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 import java.util.* import kotlin.collections.ArrayDeque object Day23 : AdventDay() { override fun solve() { val data = reads\u0026lt;String\u0026gt;() ?: return val extraLines = listOf(\u0026#34; #D#C#B#A#\u0026#34;, \u0026#34; #D#B#A#C#\u0026#34;) data.findMinEnergy(maxRow = 3).printIt() data.addExtraLines(extraLines, startFrom = 3) .findMinEnergy(maxRow = 3 + extraLines.size).printIt() } } private fun List\u0026lt;String\u0026gt;.addExtraLines(lines: List\u0026lt;String\u0026gt;, startFrom: Int) = buildList { this@addExtraLines.take(startFrom).forEach { add(it) } lines.forEach { add(it) } this@addExtraLines.drop(startFrom).forEach { add(it) } } private class WayDescription(val collides: Set\u0026lt;F\u0026gt;, val steps: Int) private class MapDescription(val spaces: Set\u0026lt;F\u0026gt;, val collides: DefaultMap\u0026lt;F, DefaultMap\u0026lt;F, WayDescription\u0026gt;\u0026gt;) private fun List\u0026lt;String\u0026gt;.toMapDescription(maxRow: Int): MapDescription { val map = DefaultMap\u0026lt;F, ModelField\u0026gt;(ModelField.Wall).also { map -\u0026gt; forEachIndexed { y, line -\u0026gt; line.forEachIndexed { x, c -\u0026gt; F(x, y, maxRow).also { map[it] = c.toModelField(it) } } } } val spaces = map.entries.filter { it.value == ModelField.Used }.mapTo(HashSet()) { it.key } val collides = spaces .associateWith { scanPaths(start = it, spaces - it, map) } .toDefaultMap(DefaultMap(WayDescription(emptySet(), steps = 0))) return MapDescription(spaces, collides) } private fun List\u0026lt;String\u0026gt;.toMapState(maxRow: Int) = buildMap { forEachIndexed { y, line -\u0026gt; line.forEachIndexed { x, c -\u0026gt; F(x, y, maxRow).takeIf { it.isFinalPlace }?.let { put(it, AmphiodType.valueOf(\u0026#34;$c\u0026#34;)) } } } }.let { MapState(it) } private fun scanPaths(start: F, positions: Set\u0026lt;F\u0026gt;, map: Map\u0026lt;F, ModelField\u0026gt;): DefaultMap\u0026lt;F, WayDescription\u0026gt; { val path = DefaultMap\u0026lt;F, WayDescription\u0026gt;(WayDescription(emptySet(), 0)) val visited = hashSetOf\u0026lt;F\u0026gt;() val queue = ArrayDeque\u0026lt;F\u0026gt;().also { it += start } tailrec fun go(curr: F) { curr.also { visited += it }.neighbours() .filterNot { it in visited } .filter { map[it] == ModelField.Used || map[it] == ModelField.Space } .onEach { queue += it } .forEach { path[it] = WayDescription( if (curr in positions) path[curr].collides + curr else path[curr].collides, steps = path[curr].steps + 1 ) } go(queue.removeFirstOrNull() ?: return) } return path.also { go(start) } } private fun List\u0026lt;String\u0026gt;.findMinEnergy(maxRow: Int): Long? { data class Reached(val state: MapState, val energy: Long) val mapDescription = toMapDescription(maxRow) val mapState = toMapState(maxRow) val dist = DefaultMap\u0026lt;MapState, Long\u0026gt;(Long.MAX_VALUE).also { it[mapState] = 0 } val queue = PriorityQueue(compareBy(Reached::energy)).also { it += Reached(mapState, 0) } while (queue.isNotEmpty()) { val curr = queue.remove() if (curr.state.isFinal) return dist[curr.state] curr.state.reachable(mapDescription).forEach neigh@{ (to, energy) -\u0026gt; val alt = dist[curr.state] + energy if (alt \u0026gt;= dist[to]) return@neigh dist[to] = alt queue += Reached(to, alt) } } return null } private data class MapStateChange(val mapState: MapState, val energy: Int) private data class MapState(val positions: Map\u0026lt;F, AmphiodType\u0026gt;) { val isFinal by lazy { positions.all { it.value.col == it.key.x } } val byX: LazyDefaultMap\u0026lt;Int, HashSet\u0026lt;AmphiodType\u0026gt;\u0026gt; by lazy { LazyDefaultMap\u0026lt;Int, HashSet\u0026lt;AmphiodType\u0026gt;\u0026gt;(::hashSetOf).apply { positions.forEach { (f, type) -\u0026gt; this[f.x] += type } } } fun reachable(mapDescription: MapDescription) = if (isFinal) emptySequence() else sequence { val freeSpaces = mapDescription.spaces - positions.keys for ((from, type) in positions) { val otherPositions = HashMap(positions).also { it -= from } for (moveTo in freeSpaces) { if (!(from.isHallway xor moveTo.isHallway)) continue if (from.isHallway \u0026amp;\u0026amp; type.col != moveTo.x) continue if (moveTo.isFinalPlace \u0026amp;\u0026amp; byX[moveTo.x].any { it != type }) continue if (from.isFinalPlace \u0026amp;\u0026amp; from.x == type.col \u0026amp;\u0026amp; byX[from.x].all { it == type }) continue val onWay = mapDescription.collides[from][moveTo] if ((onWay.collides - freeSpaces).isNotEmpty()) continue val updatedMap = MapState(HashMap(otherPositions).also { it[moveTo] = type }) yield(MapStateChange(updatedMap, onWay.steps * type.energy)) } } } } private enum class ModelField { Wall, Space, Used } private enum class AmphiodType(val energy: Int, val col: Int) { A(1, 3), B(10, 5), C(100, 7), D(1000, 9) } private data class F(val x: Int, val y: Int, private val maxRow: Int) { val isHallway = y == 1 val isFinalColumn = x in FINAL_COLUMNS val isFinalRow = y in 2..maxRow val isFinalPlace = isFinalRow \u0026amp;\u0026amp; isFinalColumn fun neighbours() = sequenceOf(f(x + 1, y), f(x, y - 1), f(x - 1, y), f(x, y + 1)) private fun f(x: Int, y: Int) = copy(x = x, y = y) companion object { private val FINAL_COLUMNS = AmphiodType.values().map { it.col }.toHashSet() } } private fun Char.toModelField(f: F) = when { this == \u0026#39;#\u0026#39; || this == \u0026#39; \u0026#39; -\u0026gt; ModelField.Wall f.isFinalColumn \u0026amp;\u0026amp; f.isHallway -\u0026gt; ModelField.Space else -\u0026gt; ModelField.Used } Extra notes Let\u0026rsquo;s take a look at the data class F that we defined for the field on the map. It\u0026rsquo;s worth noticing how data classes work in Kotlin. If we take a look at the bytecode generated for this class, we would see such fragment\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 public int hashCode(); Code: 0: aload_0 1: getfield #13 // Field x:I 4: invokestatic #108 // Method java/lang/Integer.hashCode:(I)I 7: istore_1 8: iload_1 9: bipush 31 11: imul 12: aload_0 13: getfield #16 // Field y:I 16: invokestatic #108 // Method java/lang/Integer.hashCode:(I)I 19: iadd 20: istore_1 21: iload_1 22: bipush 31 24: imul 25: aload_0 26: getfield #19 // Field maxRow:I 29: invokestatic #108 // Method java/lang/Integer.hashCode:(I)I 32: iadd 33: istore_1 34: iload_1 35: ireturn that is a representation of hashCode method for this class. We can see here, that in case of data classes the hashCode, as well as equals, toString and other generated method takes into account only the fields that are a part of primary constructor of the class (so in this case x, y and maxRow fields) and the other fields declared in class are not taken into account. The same applies to the inheritance from some other classes - their fields will not be taken into account if we use data classes, so all the generated methods will only consider the fields from constructor from data class. That\u0026rsquo;s because this type of classes is intended to use with no inheritance, so model some really simple data. We have to have this in the back of our minds, not to make some unreal assumptions about the generated code.\n","date":"2021-12-23T00:00:00Z","image":"https://procyk.in/post/advent-of-code-2021-23/featured_hu11148368822655655124.jpg","permalink":"https://procyk.in/post/advent-of-code-2021-23/","title":"Advent of Code 2021 in Kotlin - Day 23"},{"content":"Introduction The Day 22 problem is the next example of problem that is strictly divided in two parts, that seems to be identical but requires much different solutions. In the first part we can start with naive implementation which is good as the considered space is limited but in the second part we have to come up with some smarter approach. Let\u0026rsquo;s see the idea behind and the cool implementation in Kotlin.\nSolution For the first part we prepare straightforward solution which keeps all the cubes in space separately, as their number is limited by task description (i.e. it can be at most $101^2$). So for every Step we take care only about the Cubes from limited range and add them or remove from current collection.\nHowever, in the second part this approach is too naive. That\u0026rsquo;s because the sizes of the added and removed cubes are really huge, so adding individual Cubes in space would take too much time and memory.\nAfter some time of thinking about the solution, we can come up with the approach of inserting 3D ranges to reactor, so instead of keeping information about individual cubes, we keep the groups of them.\nThe hardest part of the solution is to implement the difference of Range3D that we represented as a triple of IntRange. To do that, we provided a few helper infix function that makes checking relative position of ranges easier. In my opinion, the hardest part was the proper implementation of operator fun IntRange.minus(r: IntRange) that is later used in operator fun Range3D.minus(r: Range3D). The main idea behind this approach is to divide the considered Range3Ds into 8 (or less) smaller pieces and check which of them are in the result Range3D.\nDay22.kt 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 import kotlin.math.max import kotlin.math.min object Day22 : AdventDay() { override fun solve() { val data = reads\u0026lt;String\u0026gt;() ?: return val steps = data.map { it.toStep() } LimitedReactor(limit = -50..50).apply { steps.forEach { execute(it) } }.size.printIt() Reactor().apply { steps.forEach { execute(it) } }.size.printIt() } } private fun String.toRange() = drop(2).split(\u0026#34;..\u0026#34;) .map { it.toInt() }.let { (f, t) -\u0026gt; f..t } private fun String.toStep() = split(\u0026#34; \u0026#34;).let { (a, r) -\u0026gt; val (x, y, z) = r.split(\u0026#34;,\u0026#34;).map { it.toRange() } Step(Action.valueOf(a.uppercase()), Range3D(x, y, z)) } private infix fun IntRange.limit(l: IntRange?) = l?.let { max(first, l.first)..min(last, l.last) } ?: this private enum class Action { ON, OFF } private data class Step(val action: Action, val range: Range3D) { fun cubes(l: IntRange? = null) = buildSet { for (xi in range.x limit l) for (yi in range.y limit l) for (zi in range.z limit l) add(Cube(xi, yi, zi)) } } private data class Cube(val x: Int, val y: Int, val z: Int) private class LimitedReactor(private val limit: IntRange) { private val on = hashSetOf\u0026lt;Cube\u0026gt;() val size get() = on.size fun execute(step: Step) = when (step.action) { Action.ON -\u0026gt; on += step.cubes(limit) Action.OFF -\u0026gt; on -= step.cubes(limit) } } private infix fun IntRange.outside(r: IntRange) = last \u0026lt; r.first || first \u0026gt; r.last private infix fun IntRange.inside(r: IntRange) = first \u0026gt;= r.first \u0026amp;\u0026amp; last \u0026lt;= r.last private val IntRange.size get() = last - first + 1 private operator fun IntRange.minus(r: IntRange): Sequence\u0026lt;IntRange\u0026gt; = when { this inside r -\u0026gt; sequenceOf(this) r inside this -\u0026gt; sequenceOf(first..r.first - 1, r, r.last + 1..last) r outside this -\u0026gt; sequenceOf(this) last \u0026lt; r.last -\u0026gt; sequenceOf(first..r.first - 1, r.first..last) r.first \u0026lt; first -\u0026gt; sequenceOf(first..r.last, r.last + 1..last) else -\u0026gt; error(\u0026#34;Not defined minus for $this-$r\u0026#34;) }.filter { it.size \u0026gt; 0 } private class Reactor { private val on: HashSet\u0026lt;Range3D\u0026gt; = hashSetOf() val size get() = on.sumOf { it.size } fun execute(step: Step) = when (step.action) { Action.OFF -\u0026gt; on.flatMap { it - step.range }.toHashSet().also { on.clear() } Action.ON -\u0026gt; on.fold(hashSetOf(step.range)) { cut, curr -\u0026gt; cut.flatMap { it - curr }.toHashSet() } }.let { on += it } } private data class Range3D(val x: IntRange, val y: IntRange, val z: IntRange) { val size get() = x.size.toLong() * y.size.toLong() * z.size.toLong() operator fun minus(r: Range3D): Sequence\u0026lt;Range3D\u0026gt; = if (r outside this) sequenceOf(this) else sequence { for (x in x - r.x) for (y in y - r.y) for (z in z - r.z) yield(Range3D(x, y, z)) }.filter { it inside this \u0026amp;\u0026amp; it outside r } infix fun outside(r: Range3D) = x outside r.x || y outside r.y || z outside r.z infix fun inside(r: Range3D) = x inside r.x \u0026amp;\u0026amp; y inside r.y \u0026amp;\u0026amp; z inside r.z } Extra notes The whole solution takes advantage of defining many infix and operator functions for ranges. Most of them are defined in order to get a simple way of calculating difference of many ranges.\nWhen performing most of the operations on sets of ranges, we use the sequences to produce the values. That\u0026rsquo;s because there are many transformations done on these iterables so approach with sequences is preferred. Building the sequences is in Kotlin as easy as building collections with sequence { } builder or sequenceOf() function, so we definitely should consider using them in our code more frequently.\nWe haven\u0026rsquo;t mentioned yet in our discussions the getters\u0026rsquo; implementation in Kotlin. While usually we define the field values with immediate initialisation like\n1 val someField: FieldType = calculatedSomeFieldValue() it might be not a good approach in multiple situations because the calculatedSomeFieldValue function is called just on object initialisation.\nOne of the approaches here is to provide the getter implementation of the field, so it\u0026rsquo;s values will be calculated every time when the property is accessed. We can with simple expression definition like\n1 val someField: FieldType get() = calculatedSomeFieldValue() which can be also written as multiple statements, if some extra instructions are needed to calculate result like\n1 2 3 4 val someField: FieldType get() { val intermediateValue = calculatedSomeFieldValue() return valueTransformation(intermediateValue) } In both of these cases, the function calculating the field value is called every time when the field is accessed. That\u0026rsquo;s may take a lot of resources so sometimes the lazy approach is definitely preferred. It can be used when the returned field value is known to be always the same, so it can be cached in delegated property. It\u0026rsquo;s enough to define such field as\n1 val someField: FieldType by lazy { calculatedSomeFieldValue() } Then, only at the first access of someField the calculatedSomeFieldValue is called. It\u0026rsquo;s pretty and short approach to get a really cool effect, so we should remember about it when defining the fields in our classes (especially when they depend on some objects\u0026rsquo; state) ðŸ¤ž.\n","date":"2021-12-22T00:00:00Z","image":"https://procyk.in/post/advent-of-code-2021-22/featured_hu3112988478271299452.jpg","permalink":"https://procyk.in/post/advent-of-code-2021-22/","title":"Advent of Code 2021 in Kotlin - Day 22"},{"content":"Introduction The Day 21 problem starts with a pretty simple and obvious part of not random dice game, while in second part we have to think deeper how to efficiently simulate multiple paths of quantum game that may appear. Let\u0026rsquo;s see then how we can deal with both parts by working with model built with immutable objects.\nSolution We simulate the game with its immutable representation as DiceGame that holds points for both players and the order of players to move. We added to it some helper methods looser and winner which are designed to answer the question \u0026ldquo;Was the last moved player a looser/winner?\u0026rdquo; as we use them only after player moves. We\u0026rsquo;re able to transform such a game with some dice value by creating a new instance of game with points of player updated and players switched. As it is an immutable data, we used fold once again as in multiple previous problems to simulate state change of such object.\nIn the second part, we have to count the worlds, in which players win. As the number of possible values of dice is limited, we write them to QUANTUM_DICE_SPLITS for better readability of our intention. The numbers on right represent on how many ways we have get every sum from left, when the possible sums are listed in comment.\nThen, the simulation of quantum game have to count the occurrences of each game instead of keeping them in some collection. For example, instead of having a list with 42 the same games, we just remember the game and its associated value that equals 42. We can update these values accordingly by multiplying the last count by the number of worlds splits, in which current dice value appear by simply writing\n1 updated[nextGame] = updated[nextGame] + splits * playing[game] as we\u0026rsquo;ve used the DefaultMap\u0026lt;DiceGame, Long\u0026gt; once again for simpler problem representation.\nDay21.kt 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 object Day21 : AdventDay() { override fun solve() { val data = reads\u0026lt;String\u0026gt;() ?: return val (p1, p2) = data.map { it.toPlayer() } simulateGame(p1, p2)?.let { (p, idx) -\u0026gt; p.points * idx }.printIt() simulateQuantumGame(p1, p2).maxOf { it.value }.printIt() } } private fun simulateGame(p1: Player, p2: Player): Pair\u0026lt;Player, Int\u0026gt;? { generateDiceNumbers().foldIndexed(DiceGame(p1, p2, toPoints = 1000)) { idx, game, dice -\u0026gt; game.move(dice).apply { looser()?.let { return Pair(it, 3 * (idx + 1)) } } } return null } private val QUANTUM_DICE_SPLITS = listOf( 3 to 1, // 1+1+1 4 to 3, // 1+1+2, 1+2+1, 2+1+1, 5 to 6, // 2+2+1, 2+1+2, 1+2+2, 1+1+3, 1+3+1, 3+1+1 6 to 7, // 1+2+3, 1+3+2, 2+1+3, 2+3+1, 3+1+2, 3+2+1, 2+2+2 7 to 6, // 2+2+3, 2+3+2, 3+2+2, 3+3+1, 3+1+3, 1+3+3 8 to 3, // 3+3+2, 3+2+3, 2+3+3 9 to 1, // 3+3+3 ) private fun simulateQuantumGame(p1: Player, p2: Player): Map\u0026lt;Int, Long\u0026gt; { val playing = mapOf(DiceGame(p1, p2, toPoints = 21) to 1L).toDefaultMap(0) val winCount = DefaultMap\u0026lt;Int, Long\u0026gt;(0L) while (playing.isNotEmpty()) { val updated = DefaultMap\u0026lt;DiceGame, Long\u0026gt;(0) for (game in playing.keys) { for ((dice, splits) in QUANTUM_DICE_SPLITS) { val nextGame = game.move(dice) when (val winner = nextGame.winner()) { null -\u0026gt; updated[nextGame] = updated[nextGame] + splits * playing[game] else -\u0026gt; winCount[winner.idx] = winCount[winner.idx] + splits * playing[game] } } } playing.also { it.clear() }.also { it.putAll(updated) } } return winCount } private fun generateDiceNumbers() = generateSequence(0) { it + 1 } .map { it % 100 + 1 }.windowed(size = 3, step = 3) { it.sum() } private fun String.toPlayer() = removePrefix(\u0026#34;Player \u0026#34;).run { val idx = takeWhile { it.isDigit() }.toInt() val position = dropWhile { it.isDigit() }.removePrefix(\u0026#34; starting position: \u0026#34;).toInt() Player(idx, position, points = 0) } private data class Player(val idx: Int, val position: Int, val points: Long) { fun move(rolled: Int): Player = ((position - 1 + rolled) % 10 + 1).let { copy(position = it, points = it + points) } } private data class DiceGame(val now: Player, val last: Player, val toPoints: Long) { fun move(rolled: Int): DiceGame = copy(now = last, last = now.move(rolled)) fun looser(): Player? = if (last.points \u0026gt;= toPoints) now else null fun winner(): Player? = if (last.points \u0026gt;= toPoints) last else null } Extra notes The process of generation next values of dice in the first part of problem could have been expressed in really handy way, with the usage of sequences and windowed function of them. It\u0026rsquo;s not the most performant approach to this problem as we could define closed formula for these numbers, but as it was the first part of the problem, single line solution with just\n1 generateSequence(0) { it + 1 }.map { it % 100 + 1 }.windowed(size = 3, step = 3) { it.sum() } was in my opinion the best fit here.\nNotice, that in the solution of second part, we decided to use some local updated map, which is used to store the current state of the playing games instead of modifying the playing map. We need to remember that in case of Java collections (which are used in Kotlin), we cannot modify the collection when iterating over its values. The ConcurrentModificationException is thrown, if we would try to do so. There are of course different approaches to solve such problems, e.g. we can copy the collection to iterate over copy and modify the original one or just iterate over original and modify it after iteration. The second approach seemed to give more clear result in this solution and was fast enough, so we decided to apply it to our solution.\n","date":"2021-12-21T00:00:00Z","image":"https://procyk.in/post/advent-of-code-2021-21/featured_hu17654607413269730813.jpg","permalink":"https://procyk.in/post/advent-of-code-2021-21/","title":"Advent of Code 2021 in Kotlin - Day 21"},{"content":"Introduction The Day 20 problem seemed to be quite straightforward at first sight and the base can be passed here really quickly. The magic is in boundaries conditions of the task and the given sample, that doesn\u0026rsquo;t include such situation, so we have to deal with it on ourselves.\nSolution To solve the problem of enhancing the image, we need some more information that the locations of lighten pixel (that we store in Image::enlighten field). We need to take care of the current background state, as it can also change during the enhancement. However, it can only change from fully empty to fully filled with enlighten pixels, so it\u0026rsquo;s enough if we remember only a Boolean flag for this state in fillInfty.\nIt\u0026rsquo;s not so obvious at first to include the infinity of image also in its computations, but it was definitely the hardest part of this task (and to realize what\u0026rsquo;s going on when base sample is working but the final answer is wrong).\nDay20.kt 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 object Day20 : AdventDay() { override fun solve() { val data = reads\u0026lt;String\u0026gt;() ?: return val algorithm = data.toAlgorithm() val image = data.toImage() image.enhance(algorithm, times = 2).enlighten.size.printIt() image.enhance(algorithm, times = 50).enlighten.size.printIt() } } private val Char.isLight: Boolean get() = this == \u0026#39;#\u0026#39; private fun List\u0026lt;String\u0026gt;.toAlgorithm() = take(1).single().let { Image.Algorithm(it) } private fun List\u0026lt;String\u0026gt;.toImage() = drop(2).flatMapIndexed { y, line -\u0026gt; line.mapIndexedNotNull { x, c -\u0026gt; if (c.isLight) Pixel(x, y) else null } }.toSet().let { Image(it, fillInfty = false) } private data class Pixel(val x: Int, val y: Int) { infix fun on(s: Image.Surface) = x in s.x \u0026amp;\u0026amp; y in s.y } private class Image(val enlighten: Set\u0026lt;Pixel\u0026gt;, val fillInfty: Boolean) { private val surface = with(enlighten) { Surface(minOf { it.x }..maxOf { it.x }, minOf { it.y }..maxOf { it.y }) } fun enhance(algorithm: Algorithm, times: Int) = (1..times) .fold(this) { img, _ -\u0026gt; img.enhanceStep(algorithm) } private fun enhanceStep(algorithm: Algorithm): Image = buildSet { for (x in surface.x + 1) for (y in surface.y + 1) Pixel(x, y).let { val encoding = encoding(it) val state = algorithm(encoding) if (state) add(it) } }.let { Image(it, if (fillInfty) algorithm(0b111111111) else algorithm(0b000000000)) } private fun encoding(p: Pixel) = sequence { for (yi in -1..1) for (xi in -1..1) yield(Pixel(p.x + xi, p.y + yi)) } .map { if (it on surface) it in enlighten else fillInfty } .fold(0) { acc, b -\u0026gt; 2 * acc + if (b) 1 else 0 } private operator fun IntRange.plus(i: Int) = first - i..last + i class Surface(val x: IntRange, val y: IntRange) class Algorithm(data: String) { private val lightOn: Set\u0026lt;Int\u0026gt; = data .mapIndexedNotNull { idx, c -\u0026gt; if (c.isLight) idx else null }.toSet() operator fun invoke(x: Int) = x in lightOn } } Extra notes We used extension properties as well extension functions in our solution to make it more readable. For example, it\u0026rsquo;s more convenient to define the\n1 private val Char.isLight: Boolean get() = this == \u0026#39;#\u0026#39; if we check for this equality a few times in a file, and it can be precisely named. That\u0026rsquo;s just a single line that enables nice syntax like c.isLight instead of writing the symbol explicitly with ==.\nNotice also the definition of infix fun on for Pixel class that was later used in encoding method. We can define such functions in Kotlin for every type and give them the names, which make reading code more pleasant. Remember about that, when writing your libraries in Kotlin, just to give the developers possibility to use infix notation for functions with single argument.\nOnce again, we should see and remember how the builders for collections in Kotlin can be used. Let\u0026rsquo;s see that the usage of buildSet { } contains just single nested instruction, while it is a nested for loop with the let { } usage on pixel - it\u0026rsquo;s really efficient approach of going through the image and building the new one at the same time.\nWe came up with also some tricky local definition of extension function for IntRange that made it expand in both directions by just writing\n1 private operator fun IntRange.plus(i: Int) = first - i..last + i Then, it was used to process the pixels from the border in standard loop by iterating like\n1 for (x in surface.x + 1) for (y in surface.y + 1) This kind of approach is really cool and removes a lot of code repetitions, but we need to define them usually with private visibility, as they might have been understood differently in different contexts, e.g. we could have also\n1 private operator fun IntRange.plus(i: Int) = first..last + i or even\n1 private operator fun IntRange.plus(i: Int) = first + i..last + i so always remember to make sure, that the other developers will understand what you meant or just forbid using your definitions outside your world, to make code safe ðŸ˜‰.\n","date":"2021-12-20T00:00:00Z","image":"https://procyk.in/post/advent-of-code-2021-20/featured_hu8855072166064931838.jpg","permalink":"https://procyk.in/post/advent-of-code-2021-20/","title":"Advent of Code 2021 in Kotlin - Day 20"},{"content":"Introduction In Day 19 we\u0026rsquo;re given a problem that is mostly related to the transformations in 3D space, including rotations and shifts of vectors. It\u0026rsquo;s been fun but also a hard work to implement it in Kotlin from basics in idiomatic way, so let\u0026rsquo;s see what the final solution is.\nSolution The approach to given problem is somehow straightforward as we try pairing each pair of scanners and remember the transformations needed to go from one coordinates system to another. To do that, we remember a list of transformations for each scanner, that is required to transform its coordinate system to the system of the first scanner (collected in transform map). What\u0026rsquo;s more important we also remember if we\u0026rsquo;ve already check, if there is some relation between some pair of scanners (which is remembered in triedToPair). It\u0026rsquo;s important not to check multiple times for the same $\\textnormal{fromId} \\rightarrow \\textnormal{toId}$ connection if there was no transformation found in the past. It cannot be deduced only from cahcedPair map because it has no value also if the pair was checked, and it was not found.\nWe search by starting from some start scanner that is the reference system and append next scanners, step by step, by finding next matching pairs between scanner from paired and toPair. Notice that we\u0026rsquo;ve implemented the new hashCode and equals to represent scanner by its id. This approach simplifies code a lot, so we don\u0026rsquo;t have to worry about indices when working with maps.\nDay19.kt 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 import V3.Companion.TRANSFORMS import kotlin.math.absoluteValue object Day19 : AdventDay() { override fun solve() { val data = reads\u0026lt;String\u0026gt;() ?: return val scanners = data.groupSeparatedBy(\u0026#34;\u0026#34;) { it.toScanner() } val matcher = ScannersMatcher(scanners, minCommon = 12) val start = scanners.first() val (beaconsFromStart, positioned) = matcher.findPairing(start) beaconsFromStart.size.printIt() sequence { for ((s1, v1) in positioned) for ((s2, v2) in positioned) if (s1 != s2) yield(v1 - v2) }.maxOf { it.manhattanValue }.printIt() } } private class ScannersMatcher(val scanners: List\u0026lt;Scanner\u0026gt;, val minCommon: Int) { private data class FT(val from: Scanner, val to: Scanner) private val cachedPair = mutableMapOf\u0026lt;FT, V3.T\u0026gt;() private val triedToPair = DefaultMap\u0026lt;FT, Boolean\u0026gt;(false) fun findPairing(start: Scanner): Pair\u0026lt;Set\u0026lt;V3\u0026gt;, Map\u0026lt;Scanner, V3\u0026gt;\u0026gt; { val transform = DefaultMap\u0026lt;Scanner, List\u0026lt;V3.T\u0026gt;\u0026gt;(emptyList()) val beacons = start.beacons.toMutableSet() val scan = mutableMapOf\u0026lt;Scanner, V3\u0026gt;().also { it[start] = V3.ZERO } val paired = mutableSetOf(start) val toPair = (scanners - paired).toMutableSet() while (toPair.isNotEmpty()) { search@ for (from in paired) for (to in toPair) { val pairedShift = tryPair(FT(from, to)) ?: continue transform[to] = transform[from] + pairedShift beacons += to.beacons.map { transform[to](it) } scan[to] = transform[to](V3.ZERO) to.also { paired += it }.also { toPair -= it } break@search } } return Pair(beacons, scan) } private fun tryPair(ft: FT): V3.T? { if (triedToPair[ft]) return cachedPair[ft] triedToPair[ft] = true for (t in TRANSFORMS) { val to = t(ft.to) val diffs = buildSet { for (fb in ft.from.beacons) for (tb in to.beacons) add(tb - fb) } for (diff in diffs) { val cnt = to.beacons.count { tb -\u0026gt; (tb - diff) in ft.from.beacons } if (cnt \u0026gt;= minCommon) return t.copy(shift = -diff).also { cachedPair[ft] = it } } } return null } } private fun List\u0026lt;String\u0026gt;.toScanner() = Scanner( first().removePrefix(\u0026#34;--- scanner \u0026#34;).takeWhile { it.isDigit() }.toInt(), drop(1).map { it.toBeacon() }.toSet() ) private fun String.toBeacon() = split(\u0026#34;,\u0026#34;).map { it.toInt() } .let { (x, y, z) -\u0026gt; V3(x, y, z) } private data class V3(val x: Int, val y: Int, val z: Int) { data class T(val id: Int, val shift: V3) val manhattanValue = x.absoluteValue + y.absoluteValue + z.absoluteValue private fun axeRotated(id: Int) = when (id) { 0 -\u0026gt; V3(x, y, z) 1 -\u0026gt; V3(-y, x, z) 2 -\u0026gt; V3(-x, -y, z) 3 -\u0026gt; V3(y, -x, z) else -\u0026gt; error(\u0026#34;Invalid axeRotate id\u0026#34;) } private fun axeChanged(id: Int) = when (id) { 0 -\u0026gt; V3(x, y, z) 1 -\u0026gt; V3(x, z, -y) 2 -\u0026gt; V3(x, -z, y) 3 -\u0026gt; V3(x, -y, -z) 4 -\u0026gt; V3(-z, y, x) 5 -\u0026gt; V3(z, y, -x) else -\u0026gt; error(\u0026#34;Invalid axeChanged id\u0026#34;) } infix fun transformedBy(by: T) = axeChanged(by.id / 4).axeRotated(by.id % 4) + by.shift operator fun plus(v3: V3) = V3(x + v3.x, y + v3.y, z + v3.z) operator fun minus(v3: V3) = V3(x - v3.x, y - v3.y, z - v3.z) operator fun unaryMinus() = ZERO - this companion object { val ZERO = V3(0, 0, 0) val TRANSFORMS = (0..23).map { T(it, ZERO) } } } private class Scanner(val id: Int, val beacons: Set\u0026lt;V3\u0026gt;) { override fun equals(other: Any?) = (other as? Scanner)?.id == id override fun hashCode() = id } private operator fun List\u0026lt;V3.T\u0026gt;.invoke(v: V3) = foldRight(v) { t, v3 -\u0026gt; v3 transformedBy t } private operator fun V3.T.invoke(s: Scanner) = Scanner(s.id, s.beacons.map { it transformedBy this }.toSet()) Extra notes We have used in the solution a few cool Kotlin features that are definitely worth mentioning. Let\u0026rsquo;s look at the:\nDefinitions of invoke functions that are declared as operators for transformations of vectors. In this way we got some cool syntax to actually applying transformation to vector or scanner. We encoded the transformation on vector as a number from range 0..23 which includes the rotation and the change of the z axe of the coordinate system. It was pretty hard to express it in some good way, so we decided to do it explicitly with writing all possible transformations by hand. If it\u0026rsquo;s not readable, I encourage you to use your first 3 finger of your hand and see how these axes are transformed (that\u0026rsquo;s what I did in fact). Take a look at the operator fun defined for V3 class representing the operations on vectors. They\u0026rsquo;re somehow obvious, but we have to remember that it\u0026rsquo;s convenient to define them as overloaded operators in Kotlin. In the search of pair matches we used the named scope search@ - in this way we can exit the outer loop in Kotlin (and other modern programming languages) and it somehow simplifies the code. Once again we\u0026rsquo;ve used the builders methods that\u0026rsquo;re new stable feature from Kotlin - building iterables with buildSet { } and sequence { } is really pleasant and straightforward. ","date":"2021-12-19T00:00:00Z","image":"https://procyk.in/post/advent-of-code-2021-19/featured_hu743570444373735622.jpg","permalink":"https://procyk.in/post/advent-of-code-2021-19/","title":"Advent of Code 2021 in Kotlin - Day 19"},{"content":"Introduction In Day 18 comes up with the problem the is described in a crazy way. There is no tree structure mentioned in the description, however we can notice that this seems to be the best structure to represent given data. Let\u0026rsquo;s see how to do it in Kotlin.\nSolution We represent the data specifically as binary tree, that can be TreeParent node with two children or TreeLeaf that holds some number value. Because of the modifications that are going to happen on that trees, we represent them as mutable data, not to copy too much of them if not needed.\nThen we can see that concatenating trees is really simple - it requires only creating new node, making it a parent for old parents and assigning all its children. Basically, it can be implemented as simply as in operator fun plus for TreeNode. However, implementation of this function includes reduction of the result, as described in problem description.\nDuring the reduction we deal with two different types of events:\nFor explodes we need to find the first node that is at depth 4 or more and has two number children. This can be done with tree scanning with helper function findToExpldde. Its role is to go at least at depth 4 in tree and then return the left most parent that has both number children. Then, to implement the explosion functionality, we need to find the left and right siblings of these nodes in tree. We can find e.g. the right sibling by going up as long as we go only from right child, then take the right child of the node to which we came from left, and go left to find the right sibling of the starting node. We implemented this functionality with some pretty functions, that allows to select the directions of traversal like 1 2 3 4 explode .goUpFrom { left } ?.left ?.updateOnMost({ right }) { it + leftValue } so don\u0026rsquo;t require any code repetitions for symmetrical cases. The final exchange of node to zero is easy, as we have a reference to parent node, so we can change the child to TreeLeaf with value 0. Also, the split functionality is pretty straightforward when we have a pointer to the parent node. So our task here is to find the first node with big enough value and exchange it with a node holding two values - e.i. the functionalities of findToSplit and split functions. Day18.kt 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 object Day18 : AdventDay() { override fun solve() { val data = reads\u0026lt;String\u0026gt;() ?: return val snailFish = data.map { it.toSnailFish() } snailFish.reduce { l, r -\u0026gt; l + r }.magnitude().printIt() sequence { for (l in snailFish) for (r in snailFish) if (l != r) yield(l + r) }.maxOf { it.magnitude() }.printIt() } } private sealed class TreeNode(var parent: TreeParent?) { abstract fun copy(with: TreeParent? = null): TreeNode } private class TreeLeaf(var value: Int, parent: TreeParent?) : TreeNode(parent) { override fun copy(with: TreeParent?) = TreeLeaf(value, with) } private class TreeParent(parent: TreeParent? = null) : TreeNode(parent) { lateinit var left: TreeNode lateinit var right: TreeNode override fun copy(with: TreeParent?) = TreeParent(with).also { it.left = left.copy(it) it.right = right.copy(it) } } private fun String.toSnailFish(): TreeNode = asSequence().run { fun Sequence\u0026lt;Char\u0026gt;.parse(parent: TreeParent? = null): Pair\u0026lt;TreeNode, Sequence\u0026lt;Char\u0026gt;\u0026gt; = when (first()) { \u0026#39;[\u0026#39; -\u0026gt; { val fish = TreeParent(parent) val (left, fstRest) = drop(\u0026#34;[\u0026#34;.length).parse(fish) val (right, sndRest) = fstRest.drop(\u0026#34;,\u0026#34;.length).parse(fish) Pair(fish.also { it.left = left; it.right = right }, sndRest.drop(\u0026#34;]\u0026#34;.length)) } else -\u0026gt; Pair(TreeLeaf(first().digitToInt(), parent), dropWhile { it.isDigit() }) } parse().let { (snailFish, _) -\u0026gt; snailFish } } private fun TreeNode.magnitude(): Long = when (this) { is TreeLeaf -\u0026gt; value.toLong() is TreeParent -\u0026gt; 3 * left.magnitude() + 2 * right.magnitude() } private operator fun TreeNode.plus(other: TreeNode) = TreeParent().also { parent -\u0026gt; parent.left = this.copy(parent) parent.right = other.copy(parent) }.apply { reduce() } private tailrec fun TreeNode.updateOnMost( select: TreeParent.() -\u0026gt; TreeNode, update: (Int) -\u0026gt; Int ): Unit = when (this) { is TreeLeaf -\u0026gt; value = update(value) is TreeParent -\u0026gt; select().updateOnMost(select, update) } private tailrec fun TreeParent.goUpFrom(select: TreeParent.() -\u0026gt; TreeNode): TreeParent? { val currParent = parent return if (currParent == null) currParent else if (currParent.select() == this) currParent.goUpFrom(select) else currParent } private fun TreeNode.leftFinalParent(): TreeParent? = when { this is TreeParent \u0026amp;\u0026amp; left is TreeLeaf \u0026amp;\u0026amp; right is TreeLeaf -\u0026gt; this this is TreeParent -\u0026gt; left.leftFinalParent() ?: right.leftFinalParent() else -\u0026gt; null } private fun TreeNode.changeTo(createNode: (TreeParent?) -\u0026gt; TreeNode) = when { parent?.right == this -\u0026gt; parent?.right = createNode(parent) parent?.left == this -\u0026gt; parent?.left = createNode(parent) else -\u0026gt; Unit } private fun TreeLeaf.split() = changeTo { parent -\u0026gt; TreeParent(parent).apply { left = TreeLeaf(value / 2, this) right = TreeLeaf(value / 2 + value % 2, this) } } private val TreeParent.leftValue: Int get() = (left as? TreeLeaf)?.value ?: 0 private val TreeParent.rightValue: Int get() = (right as? TreeLeaf)?.value ?: 0 private fun TreeNode.reduce() { fun TreeNode.findToExplode(level: Int): TreeParent? = when { level == 0 -\u0026gt; leftFinalParent() level \u0026gt; 0 \u0026amp;\u0026amp; this is TreeParent -\u0026gt; left.findToExplode(level - 1) ?: right.findToExplode(level - 1) else -\u0026gt; null } fun TreeNode.findToSplit(): TreeLeaf? = when (this) { is TreeLeaf -\u0026gt; if (value \u0026gt; 9) this else null is TreeParent -\u0026gt; left.findToSplit() ?: right.findToSplit() } while (true) { val explode = findToExplode(level = 4) if (explode == null) findToSplit()?.split() ?: break else explode.run { goUpFrom { left }?.left?.updateOnMost({ right }) { it + leftValue } goUpFrom { right }?.right?.updateOnMost({ left }) { it + rightValue } changeTo { parent -\u0026gt; TreeLeaf(0, parent) } } } } Extra notes Firstly, we need to notice that operator fun plus for TreeNode copies the added nodes. That\u0026rsquo;s because during the addition process they are reduced so they content may change. However, we need them unchanged in the second part of the task, so coping in this single place was needed.\nIt\u0026rsquo;s wort noticing how we implemented a few helper functions, that deal with tree structure. Let\u0026rsquo;s see that a few of them are defined as tail-recursive functions, that will be optimized by compile to while loops.\nThe last thing to notice is the definition of TreeParent that uses the lateinit var to store its children. That\u0026rsquo;s because be need to create this node first, before creating its children, to give the parent node to the children and then, after creating them, assign to parent node. This guarantees that the values will be not null after that process, so we can use the as not nullable values after initialization.\n","date":"2021-12-18T00:00:00Z","image":"https://procyk.in/post/advent-of-code-2021-18/featured_hu5085095017243348035.jpg","permalink":"https://procyk.in/post/advent-of-code-2021-18/","title":"Advent of Code 2021 in Kotlin - Day 18"},{"content":"Introduction In Day 17 brings us some physics simulation of free-falling probe that has some initial velocity. Our goal is to properly write the rules of the described world and look at the statistics from the simulations to get the problem solution. Let\u0026rsquo;s see how we can deal with it in Kotlin and why immutability rocks when performing some data transformations.\nSolution We create the representation of current state of the world and use it as immutable data in simulation - named State. It\u0026rsquo;s the most common approach to create some function in immutable class that returns this state after transformation as new object. The step method does all of this by transforming some state to another, according to described rules in the problem.\nWe run the simulation for the whole range of initial velocities that makes sense to do. They are limited, as target area is limited and time in our problem is discrete, so we have to worry only about the situations, in which we have a chance to hit target area. The key observation here is\nThe probe has no chance of hitting target area iff after single second it missed this area and is behind it.\nAs we know that after the first second the probe will be at distance $(v_x, v_y)$, we can set the ranges for initial velocities to be smaller than the distances to target are, to make sure that we checked all reasonable states in our simulations.\nDay17.kt 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 import kotlin.math.absoluteValue import kotlin.math.sign object Day17 : AdventDay() { override fun solve() { val data = reads\u0026lt;String\u0026gt;()?.singleOrNull() ?: return val targetArea = data.toTargetArea() val maxX = targetArea.x.maxOf { it.absoluteValue } val maxY = targetArea.y.maxOf { it.absoluteValue } targetArea.runSimulations(x = -maxX..maxX, y = -maxY..maxY).run { maxOf { state -\u0026gt; state.yHistory.maxOf { it } }.printIt() size.printIt() } } } private fun String.toTargetArea() = removePrefix(\u0026#34;target area: x=\u0026#34;).split(\u0026#34;, y=\u0026#34;) .map { rng -\u0026gt; rng.split(\u0026#34;..\u0026#34;).let { (from, to) -\u0026gt; from.toInt() directedTo to.toInt() } } .let { (x, y) -\u0026gt; TargetArea(x, y) } private data class TargetArea(val x: IntProgression, val y: IntProgression) { fun runSimulations(x: IntRange, y: IntRange): List\u0026lt;State\u0026gt; { return buildList { for (vx in x) for (vy in y) simulate(vx, vy)?.let { add(it) } } } fun simulate(vx: Int, vy: Int): State? { var state = State(vx, vy) while (state.canReach(this)) { state = state.step() if (state.x in x \u0026amp;\u0026amp; state.y in y) return state } return null } } private data class State( val vx: Int, val vy: Int, val x: Int = 0, val y: Int = 0, val yHistory: List\u0026lt;Int\u0026gt; = listOf(), ) { fun step() = State( x = x + vx, y = y + vy, vx = vx - vx.sign, vy = vy - 1, yHistory = yHistory + y, ) fun canReach(targetArea: TargetArea) = when { vy \u0026lt; 0 \u0026amp;\u0026amp; y \u0026lt; targetArea.y.first -\u0026gt; false vx == 0 \u0026amp;\u0026amp; x !in targetArea.x -\u0026gt; false else -\u0026gt; true } } Extra notes Notice how do we store the history of State locations with some list structure. It\u0026rsquo;s important to use List\u0026lt;T\u0026gt; instead of MutableList\u0026lt;T\u0026gt; to make sure that the State is effectively immutable. That\u0026rsquo;s one of the rules that we have to always remember - all the fields of immutable classes have to be immutable, not only final.\nIt\u0026rsquo;s worth noticing that some cool properties from kotlin.math were used in presented solution. We have used the sign value of number to simulate the drag on the probe with simple expression. Additionally, the absoluteValue property was used to calculate the actual range of searching for our simulation.\n","date":"2021-12-17T00:00:00Z","image":"https://procyk.in/post/advent-of-code-2021-17/featured_hu2775955734099300594.jpg","permalink":"https://procyk.in/post/advent-of-code-2021-17/","title":"Advent of Code 2021 in Kotlin - Day 17"},{"content":"Introduction In Day 16 problem starts with a really long description. In my opinion, this type of tasks are the worst ones, as they come with a hard-to-understand problem, for which solution is really straightforward, but only when written in imperative approach with multiple nesting of code. Let\u0026rsquo;s see how we can approach this kind of problems in Kotlin by using context of the operation and lazy initialized variables in classes.\nSolution Understanding the whole description of the task is the most difficult part of it. we should take our time, read it at leas twice and try to analyze given examples in practice. After that, we can go to actual implementation that contains a few fascinating concepts of Kotlin code.\nWe convert the given data from hex to bits using the String extension function toInt with specified radix and then extracting every of bits with divide and mod operations. It may look obvious but of course I started with explicitly specifying each case from task and came up with this nice approach after some refactorings.\n1 2 3 private fun Char.toBits() = \u0026#34;$this\u0026#34;.toInt(radix = 16).let { sequenceOf((it / 8) % 2, (it / 4) % 2, (it / 2) % 2, it % 2) } There are two main features that allows us to have more concise and readable code which is pretty efficient in the same time. We use sequences to consume input data from bits. That\u0026rsquo;s why we define some helper function that is capable of \u0026ldquo;consuming\u0026rdquo; some beginning of the sequence and returning the rest of the sequence in the single call\n1 2 3 4 private inline fun \u0026lt;T\u0026gt; Sequence\u0026lt;T\u0026gt;.use(n: Int, action: (Sequence\u0026lt;T\u0026gt;) -\u0026gt; Unit): Sequence\u0026lt;T\u0026gt; { sequence { yieldAll(take(n)) }.let(action) return drop(n) } It\u0026rsquo;s important to highlight how the lambda scope (closure) in Kotlin works to get full understanding of the usage of this extension function. Remember, that in case of Java, when we want to capture some variable in lambda scope, then it has to be effectively final which means, that it cannot be reassigned. For example, we cannot write in Java the definition like\n1 2 3 4 5 6 7 8 9 private static int sum(int to) { int idx = 0; final int result = IntStream.iterate(1, (it) -\u0026gt; { idx += 1; // this will not compile as idx has to be final return it + 1; }).limit(to).sum(); System.out.println(idx); return result; } On the other hand, in Kotlin we can write some similar code that will compile and work as expected.\n1 2 3 4 5 6 7 8 9 private fun sum(to: Int): Int { var idx = 0 val result = generateSequence(1) { idx += 1 it + 1 }.take(to).sum() println(idx) return result } This type of approach is more complex in runtime and may be slower but gives the developer more possibilities to write some functionalities. If we look at the bytecode that is generated for such implementation we would see that the variable is stored as IntRef, so the object which field is modified. If we would like to make it work in Java, we would have to create our own class that would be capable of wrapping some value, then wrap the value and handle it properly inside the lambda scope. All these steps would introduce a lot of noise to our code, so we should be really thankful to Kotlin compiler that it does the job for us.\nWhen we know that, we can take a look at the whole implementation, where we can find updates of some vars inside the lambda of use extension function. E.g. when we want to consume the packet version value, we consume the first 3 bits and use it to update the value of version field from PacketHeader, by simply saying\n1 from.use(3) { version = it.msb().toInt() } In the following code we can find even more complex update of such variables in scope of the lambda, that in my opinion produced really readable code.\nDay16.kt 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 import kotlin.properties.Delegates.notNull object Day16 : AdventDay() { override fun solve() { val data = reads\u0026lt;String\u0026gt;()?.singleOrNull() ?: return val bits = data.asSequence().flatMap { it.toBits() } val (packet, rest) = buildPacket(from = bits) rest.requireZeros() packet.sumVersionNumbers().printIt() packet.eval().printIt() } } private typealias Bits = Sequence\u0026lt;Int\u0026gt; private fun Packet.sumVersionNumbers(): Int = when (this) { is NumberPacket -\u0026gt; header.version is OpPacket -\u0026gt; header.version + subPackets.sumOf { it.sumVersionNumbers() } } private fun Packet.eval(): Long = when (this) { is NumberPacket -\u0026gt; value is OpPacket -\u0026gt; when (header.type) { 0 -\u0026gt; subPackets.fold(0L) { acc, p -\u0026gt; acc + p.eval() } 1 -\u0026gt; subPackets.fold(1L) { acc, p -\u0026gt; acc * p.eval() } 2 -\u0026gt; subPackets.minOf { it.eval() } 3 -\u0026gt; subPackets.maxOf { it.eval() } 5 -\u0026gt; subPackets.let { (l, r) -\u0026gt; if (l.eval() \u0026gt; r.eval()) 1 else 0 } 6 -\u0026gt; subPackets.let { (l, r) -\u0026gt; if (l.eval() \u0026lt; r.eval()) 1 else 0 } 7 -\u0026gt; subPackets.let { (l, r) -\u0026gt; if (l.eval() == r.eval()) 1 else 0 } else -\u0026gt; throw IllegalStateException(\u0026#34;Unknown combination of data in packet: $this\u0026#34;) } } private fun buildPacket(from: Bits): Pair\u0026lt;Packet, Bits\u0026gt; = PacketHeader().run { val bits = from .use(3) { version = it.msb().toInt() } .use(3) { type = it.msb().toInt() } when (type) { 4 -\u0026gt; buildNumberPacket(from = bits) else -\u0026gt; buildOpPacket(from = bits) } } private fun PacketHeader.buildNumberPacket(from: Bits) = NumberPacket(header = this).run { var bits = from var reading = true while (reading) { bits = bits.use(1) { reading = it.first() == 1 } bits = bits.use(4) { value = value * 16 + it.msb() } } Pair(this, bits) } private fun PacketHeader.buildOpPacket(from: Bits) = OpPacket(header = this).run { var bits = from .use(1) { countSubPackets = it.first() == 1 } .use(if (countSubPackets) 11 else 15) { subPacketsCounter = it.msb().toInt() } subPackets = if (countSubPackets) buildList { repeat(subPacketsCounter) { val (subPacket, subBits) = buildPacket(from = bits) add(subPacket).also { bits = subBits } } } else buildList { bits = bits.use(subPacketsCounter) { bits = it while (bits.any()) { val (subPacket, subBits) = buildPacket(from = bits) add(subPacket).also { bits = subBits } } } } Pair(this, bits) } private fun Char.toBits() = \u0026#34;$this\u0026#34;.toInt(radix = 16).let { sequenceOf((it / 8) % 2, (it / 4) % 2, (it / 2) % 2, it % 2) } private inline fun \u0026lt;T\u0026gt; Sequence\u0026lt;T\u0026gt;.use(n: Int, action: (Sequence\u0026lt;T\u0026gt;) -\u0026gt; Unit): Sequence\u0026lt;T\u0026gt; { sequence { yieldAll(take(n)) }.let(action) return drop(n) } private fun Bits.msb() = fold(0L) { acc, b -\u0026gt; 2 * acc + b } private class PacketHeader { var version: Int by notNull() var type: Int by notNull() } private sealed class Packet(val header: PacketHeader) private class NumberPacket(header: PacketHeader) : Packet(header) { var value: Long = 0 } private class OpPacket(header: PacketHeader) : Packet(header) { var countSubPackets: Boolean by notNull() var subPacketsCounter: Int by notNull() var subPackets: List\u0026lt;Packet\u0026gt; by notNull() } private fun Bits.requireZeros() = if (any { it == 1 }) throw IllegalStateException(\u0026#34;Left non zero bytes\u0026#34;) else Unit Extra notes In our code we used Kotlin delegated properties multiple time. We define field in classes with e.g.\n1 var countSubPackets: Boolean by notNull() to have the instance of the class with field, which is not initialized after construction, but can be accessed as not nullable value, when initialized. That\u0026rsquo;s because Kotlin delegation properties can implement some interface when storing other value in practice. In this example we have a delegated property, which stores a nullable value, but expose it as not nullable. When the value is accessed and is not set, then the exception is thrown. It\u0026rsquo;s worth to see how this works and play with it, as it allowed us to create some hind of scope, in which we create the instance of PacketHeader and initialize its fields later, without creating any builder for it.\n","date":"2021-12-16T00:00:00Z","image":"https://procyk.in/post/advent-of-code-2021-16/featured_hu5911449683906832055.jpg","permalink":"https://procyk.in/post/advent-of-code-2021-16/","title":"Advent of Code 2021 in Kotlin - Day 16"},{"content":"Introduction In Day 15 problem seems to be the hardest that we struggled with so far. It\u0026rsquo;s not so obvious at first sight, how it should be solved and the input data for the problem is big enough to prevent us from creating brute-force solutions. Let\u0026rsquo;s see then how can we approach this problem and what are the hardest parts in its implementation.\nSolution When solving the problem, we face two problems:\nProper graph representation Designing algorithm for path finding In the first part we need to represent properly the graph based on the input data. According to problem description, we can see that our graph may be interpreted as nodes between adjacent cells from the map, where the weights of the edges are the values from cells to which we enter. In this way, we can find the shortest path (with the smallest sum of weights on edges) to get the solution for given problem.\nIt\u0026rsquo;s worth noticing that in the second part of the task we wouldn\u0026rsquo;t need to repeat the structure in graph, but modify the operations on graph representation in proper way. Unfortunately, such an approach would lead us to the less readable code in place of some memory saving. That\u0026rsquo;s why we decided to keep the whole representation in memory. In this scenario, graph building process was quite harder, as it required calculating all its nodes, but in the actual algorithm we didn\u0026rsquo;t have to worry about any graph representation.\nPath finding algorithm for this problem is a straightforward application of Dijkstra\u0026rsquo;s algorithm. It can be described in natural way as follows:\nLet\u0026rsquo;s consider two featured nodes $s, d \\in N$ from graph $G(N, E)$. We keep the current shortest distance to every node from $s$ in $dist$. So at the beginning $dist(s) = 0$ and for $n \\neq s$ we have $dist(n) = \\infty$. We consider all nodes from $N$ and in current step we extract the node $u$ with the shortest path to $s$ in current time. Having that, we consider every its neighbour $n$ - we have to check, if current distance from $s$ to $n$ is not smaller than the distance from $s$ to $u$ plus the weight of the edge between $u$ and $n$\nIn this way we build the shortest path from $s$ to every node of the graph, so at the end we can just return the length of the shortest path to destination node $d$.\nTo be able to represent the extraction process efficiently, we use the PriorityQueue which orders the nodes in it based on the distance of the node to $s$, which is stored in dist field of queue node QN.\nDay15.kt 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 import java.util.* object Day15 : AdventDay() { override fun solve() { val data = reads\u0026lt;String\u0026gt;() ?: return data.toWeightedGraph(times = 1).shortestPathLength().printIt() data.toWeightedGraph(times = 5).shortestPathLength().printIt() } } private fun List\u0026lt;String\u0026gt;.toWeightedGraph(times: Int): WeightedGraph = map { line -\u0026gt; line.mapNotNull { it.digitToIntOrNull() } }.let { data -\u0026gt; val m = data.first().size val n = data.size val md = m * times val nd = n * times LazyDefaultMap\u0026lt;N, MutableList\u0026lt;E\u0026gt;\u0026gt;(::mutableListOf).also { adj -\u0026gt; for (x in 0 until md) for (y in 0 until nd) for ((tx, ty) in listOf(x + 1 to y, x - 1 to y, x to y + 1, x to y - 1)) { if (tx !in 0 until md || ty !in 0 until nd) continue val extra = (ty / n) + (tx / m) adj[x `#` y] += E(tx `#` ty, (data[ty % n][tx % m] + extra - 1) % 9 + 1) } }.let { WeightedGraph(md, nd, it) } } private data class N(val x: Int, val y: Int) private data class E(val to: N, val w: Int) private infix fun Int.`#`(v: Int) = N(this, v) private class WeightedGraph(val m: Int, val n: Int, private val adj: Map\u0026lt;N, List\u0026lt;E\u0026gt;\u0026gt;) { fun shortestPathLength(source: N = 0 `#` 0, dest: N = m - 1 `#` n - 1): Long { data class QN(val n: N, val dist: Long) val dist = DefaultMap\u0026lt;N, Long\u0026gt;(0) val queue = PriorityQueue(compareBy(QN::dist)) adj.keys.forEach { v -\u0026gt; if (v != source) dist[v] = Long.MAX_VALUE queue += QN(v, dist[v]) } while (queue.isNotEmpty()) { val u = queue.remove() adj[u.n]?.forEach neigh@{ edge -\u0026gt; val alt = dist[u.n] + edge.w if (alt \u0026gt;= dist[edge.to]) return@neigh dist[edge.to] = alt queue += QN(edge.to, alt) } } return dist[dest] } } Extra notes We used some cool Kotlin features to implement the parsing process as well as the path finding algorithm, so let\u0026rsquo;s take a look to code one more time with details.\nWe decided to define some infix fun that is capable of creating nodes of graph. In Kotlin, we can define this kind of function for any type, the only restriction is the number of parameters of such functions that has to be equal to 1. It gives us the possibility to design some cool API, as the presented # for building graph nodes with 2 coordinates.\nIn Dijkstra implementation we used the named lambda neigh and the return@neigh statement. This approach was better than traditional continue in for loop because adj[u.n] might have been null, based on the Map\u0026lt;K, V\u0026gt; API (as would need extra care with ?: emptyList()). If you\u0026rsquo;re new to such a syntax, then let\u0026rsquo;s read the deep dive into similar problem with crossinline from Day 6 where this construct was used without giving extra name to the scope - here we could also write return@forEach but presented approach is more readable and fancy ðŸ˜Ž.\n","date":"2021-12-15T00:00:00Z","image":"https://procyk.in/post/advent-of-code-2021-15/featured_hu9911895546299809504.jpg","permalink":"https://procyk.in/post/advent-of-code-2021-15/","title":"Advent of Code 2021 in Kotlin - Day 15"},{"content":"Introduction In Day 14 seems to be pretty straightforward when we read it for the first time and try to implement brute-force solution. When it comes to running the same approach for some larger data, it becomes impossible as may take exponential time and memory - let\u0026rsquo;s see then how to come up with some smarter solution ðŸ˜‰.\nSolution We may try to represent the current state of the polymer as counts of every pair of consecutive letters in polymer. We can do that because we are interested only in the occurrences of subsequences of size 2 in our polymer, not in their order. To build such a representation, we can use windowed(2) function to iterate through the String that represents the polymer and count every type of subsequence. Let\u0026rsquo;s see that we need to remember also the first and the last character in polymer in our representation. It\u0026rsquo;s required in Polymer::counts - when we want to count the number of each character in polymer, we count these characters in the counts of subsequences, but these subsequences are overlapping and every almost every character in them is counted twice - apart from the first and the last characters that we count manually with\n1 2 this[first] = this[first] + 1 this[last] = this[last] + 1 At the end we need to divide the counts values by 2 (just with mapValues { it.value / 2 }) because of the described representation.\nIt\u0026rsquo;s worth noticing that in brute-force approach the data may grow exponentially as there may be even a situation in which the length of polymer is almost doubled in single step (e.g. with AAAA and AA -\u0026gt; B we get ABABABA). That\u0026rsquo;s why we need to provide such a smart approach to this problem ðŸ˜Ž.\nDay14.kt 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 object Day14 : AdventDay() { override fun solve() { val data = reads\u0026lt;String\u0026gt;() ?: return val polymer = data.firstOrNull()?.toPolymer() ?: return val rules = data.toInsertionRules() polymer.apply(rules, times = 10).stats().printIt() polymer.apply(rules, times = 40).stats().printIt() } } private fun String.toPolymer() = windowed(2).groupingBy { it }.eachCount() .mapValues { it.value.toLong() }.let { Polymer(it, first(), last()) } private fun List\u0026lt;String\u0026gt;.toInsertionRules() = buildMap { this@toInsertionRules.drop(2).forEach { line -\u0026gt; line.split(\u0026#34; -\u0026gt; \u0026#34;).let { (from, to) -\u0026gt; put(from, listOf(from.first() + to, to + from.last())) } } }.let { InsertionRules(it) } private data class Polymer(val counts: Map\u0026lt;String, Long\u0026gt;, val first: Char, val last: Char) { fun apply(rules: InsertionRules, times: Int) = (1..times).fold(this) { p, _ -\u0026gt; rules(p) } fun stats() = counts().run { maxOf { it.value } - minOf { it.value } } fun counts() = DefaultMap\u0026lt;Char, Long\u0026gt;(0).apply { counts.forEach { (p, cnt) -\u0026gt; p.forEach { this[it] = this[it] + cnt } } this[first] = this[first] + 1 this[last] = this[last] + 1 }.run { mapValues { it.value / 2 } } } private data class InsertionRules(val change: Map\u0026lt;String, List\u0026lt;String\u0026gt;\u0026gt;) { operator fun invoke(polymer: Polymer): Polymer = DefaultMap\u0026lt;String, Long\u0026gt;(0).apply { polymer.counts.forEach { (pattern, count) -\u0026gt; (change[pattern] ?: listOf(pattern)).forEach { this[it] = this[it] + count } } }.let { polymer.copy(counts = it) } } Extra notes Notice that we defined the operator fun invoke for InsertionRules. It\u0026rsquo;s one more and in my opinion really nice operator in Kotlin that can be defined for any class. We can think of it as about applying some class to the other e.g. in our class we apply InsertionRules to Polymer to get some new Polymer. Then, taking Polymer and applying some rules many times to it can be defined in single line with such a pretty syntactically code\n1 fun apply(rules: InsertionRules, times: Int) = (1..times).fold(this) { p, _ -\u0026gt; rules(p) } Keep in mind that this kind of operator exists in Kotlin especially when you design some libraries as there are many cases in which such syntax look just ðŸ†’ for other developers.\n","date":"2021-12-14T00:00:00Z","image":"https://procyk.in/post/advent-of-code-2021-14/featured_hu7969245018267312670.jpg","permalink":"https://procyk.in/post/advent-of-code-2021-14/","title":"Advent of Code 2021 in Kotlin - Day 14"},{"content":"Introduction In Day 13 is focused on implementing the proper way of representing folds of origami transparent cards that finally get some patterns on them. This task is quite easy when we choose some simple (maybe not natural) representation of our card - let\u0026rsquo;s see that in action.\nSolution The first idea might be to represent the state as 2D array or map from points to value on the plane and try to manipulate them. But it\u0026rsquo;s worth noticing that it\u0026rsquo;s enough if we remember only the dots positions on the plane. That\u0026rsquo;s because having them, we are able to create their equivalents on the other side of fold axe.\nSo having that, we\u0026rsquo;re almost done - just find out how to find the new locations of the dots after some fold. We consider only the case of x fold, as the second is analogous. When we want to fold the plane along x, we see how far it is from the folding coord with it.x - coord and put it at that distance from coord by defining the mirrored position as coord - (it.x - coord).\nDay13.kt 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 object Day13 : AdventDay() { override fun solve() { val data = reads\u0026lt;String\u0026gt;() ?: return val paper = data.toPaper() val commands = data.toCommands() commands.firstOrNull()?.let { paper.fold(it) }?.dots?.size.printIt() commands.fold(paper) { p, cmd -\u0026gt; p.fold(cmd) }.printIt() } } private fun List\u0026lt;String\u0026gt;.toPaper() = takeWhile { it.isNotBlank() }.map { line -\u0026gt; line.split(\u0026#34;,\u0026#34;).map { it.value\u0026lt;Int\u0026gt;() }.let { (x, y) -\u0026gt; V2(x, y) } }.let { Paper(it.toSet()) } private fun String.toFoldCmd() = removePrefix(\u0026#34;fold along \u0026#34;).split(\u0026#34;=\u0026#34;) .let { (axe, coord) -\u0026gt; FoldCmd(coord.toInt(), FoldAxe.valueOf(axe)) } private fun List\u0026lt;String\u0026gt;.toCommands() = dropWhile { it.isNotBlank() }.drop(1).map { it.toFoldCmd() } private data class V2(val x: Int, val y: Int) private enum class FoldAxe { x, y } private data class FoldCmd(val coord: Int, val axe: FoldAxe) private data class Paper(val dots: Set\u0026lt;V2\u0026gt;) { fun fold(cmd: FoldCmd): Paper = with(cmd) { val (orig, mod) = when (axe) { FoldAxe.x -\u0026gt; dots.partition { it.x \u0026lt;= coord }.let { (left, right) -\u0026gt; Pair(left, right.map { it.copy(x = coord - (it.x - coord)) }) } FoldAxe.y -\u0026gt; dots.partition { it.y \u0026lt;= coord }.let { (up, down) -\u0026gt; Pair(up, down.map { it.copy(y = coord - (it.y - coord)) }) } } Paper((orig + mod).toSet()) } override fun toString() = buildString { for (y in 0..dots.maxOf { it.y }) { for (x in 0..dots.maxOf { it.x }) { append(if (V2(x, y) in dots) \u0026#39;#\u0026#39; else \u0026#39;.\u0026#39;) } appendLine() } } } Extra notes We used some quite new and pretty Kotlin function when writing this solution which are worth mentioning here. It\u0026rsquo;s buildString { } builder method that was stabilized not so long time ago. There are a few more builders in Kotlin that can be used also for build the collections in that manner. For example, we can use also the buildList, buildSet and buildMap to create these collections in similar manner, with the usage of loops and some conditions.\n","date":"2021-12-13T00:00:00Z","image":"https://procyk.in/post/advent-of-code-2021-13/featured_hu10988078622261344658.jpg","permalink":"https://procyk.in/post/advent-of-code-2021-13/","title":"Advent of Code 2021 in Kotlin - Day 13"},{"content":"Introduction In Day 12 problem we are asked to fins all possible paths between some nodes in graph with some extra restrictions. The given data that describes the graphs is quite small because the problem of finding paths in graph is hard as there may be theoretically a lot of paths to be found.\nSolution We solve given problem with DFS algorithm in which we keep track of the current list of visited nodes from source. Additionally, we don\u0026rsquo;t mark some nodes as visited when entering them because they can be visited unlimited number of times.\nWe create an extra check to create common method for both parts of the problem so in the second we just mark some flag that allows us to visit single node twice. Notice, how tricky can be Kotlin definitions to make code more concise - we can write that\n1 if (curr == to) currPath.also { reached += it }.also { return } i.e. condition checking, modifying collection and returning in just single line of Kotlin code ðŸ˜.\nWe represent the graph in our approach as the map from node to the set of its adjacent nodes. To get such representation we need to group our edges and their flipped copies by the first element.\nDay12.kt 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 object Day12 : AdventDay() { override fun solve() { val graph = reads\u0026lt;String\u0026gt;()?.toGraph() ?: return graph.allPaths(Cave(\u0026#34;start\u0026#34;), Cave(\u0026#34;end\u0026#34;)).size.printIt() graph.allPaths(Cave(\u0026#34;start\u0026#34;), Cave(\u0026#34;end\u0026#34;), allowTwice = true).size.printIt() } } private fun List\u0026lt;String\u0026gt;.toGraph() = map { line -\u0026gt; line.split(\u0026#34;-\u0026#34;).map { Cave(it) }.let { (f, s) -\u0026gt; Pair(f, s) } }.let { Graph(it) } @JvmInline private value class Cave(val name: String) { fun isBig() = name.any { it.isUpperCase() } } private class Graph(edges: List\u0026lt;Pair\u0026lt;Cave, Cave\u0026gt;\u0026gt;) { private val adj = (edges + edges.map { Pair(it.second, it.first) }) .groupBy(keySelector = { it.first }, valueTransform = { it.second }) .mapValues { it.value.toSet() } fun allPaths(from: Cave, to: Cave, allowTwice: Boolean = false): Set\u0026lt;List\u0026lt;Cave\u0026gt;\u0026gt; { val reached = mutableSetOf\u0026lt;List\u0026lt;Cave\u0026gt;\u0026gt;() fun dfs(curr: Cave, path: List\u0026lt;Cave\u0026gt;, visited: DefaultMap\u0026lt;Cave, Int\u0026gt;, canVisitAgain: Boolean) { val currPath = path + curr if (curr == to) currPath.also { reached += it }.also { return } val currVisited = if (curr.isBig()) visited else visited + (curr to visited[curr] + 1) adj[curr]?.asSequence() ?.filter { visited[it] == 0 || (canVisitAgain \u0026amp;\u0026amp; visited[it] == 1) } ?.filterNot { it == from } ?.forEach { dfs(it, currPath, currVisited, if (visited[it] == 1) false else canVisitAgain) } } return reached.also { dfs(from, emptyList(), DefaultMap(0), allowTwice) } } } Extra notes See that we use some magical value class in this problem which is some new Kotlin construct that corresponds to old inline classes. They have some similar properties as data classes as they have a lot of predefined functions, but they can (and have to) have only a single field with some value (for now).\nBasically, we can learn a lot about them from the KEEP that introduced them to the language, but they were introduced because of a few reasons. They allow us to create new types with no overhead in performance and memory. That means it\u0026rsquo;s much more powerful than introducing the typealias to our model. That\u0026rsquo;s because defining\n1 2 @JvmInline value class Name(val value: String) is much more powerful than having\n1 typealias Name = String because in the second situation we can mix String with Name while in the first we cannot. Additionally, for value classes we can define extra functions that can be called only for them - same as we would work with some custom type.\nThere is also a lot of effort in improving performance of such data, so we can read about Project Valhalla in the KEEP description. It describes also the possibility of optimizing the arrays of such created types, so they could be as arrays of primitives in memory.\n","date":"2021-12-12T00:00:00Z","image":"https://procyk.in/post/advent-of-code-2021-12/featured_hu10914082682786511280.jpg","permalink":"https://procyk.in/post/advent-of-code-2021-12/","title":"Advent of Code 2021 in Kotlin - Day 12"},{"content":"Introduction The Day 11 problem requires form us writing some simulation of flashing in described manner. We can implement this in some readable way by using custom data structures and redefining some operators in Kotlin - let\u0026rsquo;s begin and see how to express some complicated code in a few lines of text.\nSolution We defined the operators for modifying internal values of the map to get extra functionality by calculating posOf i.e. the map from values to the positions where we can find every of them on the map. Thanks to this function we can always ask about the places with energy equal to 10 (in constant time) and propagate the energy from them in single flash execution.\nLet\u0026rsquo;s notice that we defined the flash function as tailrec fun so it is optimized by the compiler to standard loop. We did that because it\u0026rsquo;s usually more readable to see that was our intention when writing this code - we want to mark current positions as flashed, then for every of them propagate the energy to its neighbours and then try to flash again from the positions on which the maxVal appeared in current step of flashing.\nIt\u0026rsquo;s worth mentioning also how we defined the LazyDefaultMap\u0026lt;K, V\u0026gt; (and modified DefaultMap\u0026lt;K, V\u0026gt;) when solving this task. Now we ended up with the definition, that allows to compute the default value lazily, but also it sets the computed value to the backing map. It seemed to be more reasonable approach as we think about the value extracted from map as it would be in it - so when it\u0026rsquo;s a mutable value, then after its modifications, we should observe this modification in map.\n1 2 3 4 5 6 class LazyDefaultMap\u0026lt;K, V\u0026gt;( private val default: () -\u0026gt; V, private val map: MutableMap\u0026lt;K, V\u0026gt; = HashMap() ) : MutableMap\u0026lt;K, V\u0026gt; by map { override fun get(key: K): V = map.getOrDefault(key, default()).also { map[key] = it } } Don\u0026rsquo;t miss the definitions that uses Sequence\u0026lt;T\u0026gt; in today code - they both were defined to improve code readability and keep the performance in my opinion - let me know what you think about such \u0026ldquo;functional\u0026rdquo; approaching to the problems ðŸ˜‰.\nDay11.kt 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 object Day11 : AdventDay() { override fun solve() { val map = reads\u0026lt;String\u0026gt;()?.toEnergyMap() ?: return with(map.copy()) { (1..100).fold(0) { sum, _ -\u0026gt; sum + simulateStep() }.printIt() } with(map.copy()) { generateSequence(1, Int::inc).first { simulateStep() == 100 }.printIt() } } } private fun List\u0026lt;String\u0026gt;.toEnergyMap() = EnergyMap(maxVal = 10, map { line -\u0026gt; line.map { it.digitToInt() }.toMutableList() }) private data class Pos(val x: Int, val y: Int) private data class EnergyMap(val maxVal: Int, private val values: List\u0026lt;MutableList\u0026lt;Int\u0026gt;\u0026gt;) { val indices = values.flatMapIndexed { y, row -\u0026gt; row.indices.map { Pos(it, y) } } private val posOf = LazyDefaultMap(::mutableSetOf, indices.groupBy { this[it] }.mapValues { it.value.toMutableSet() }.toMutableMap() ) fun copy() = EnergyMap(maxVal, values.map { it.toMutableList() }) operator fun get(p: Pos): Int = with(p) { values[y][x] } operator fun set(p: Pos, v: Int) { val newVal = v.coerceAtMost(maxVal) posOf[this[p]].remove(p) posOf[newVal].add(p) values[p.y][p.x] = newVal } fun neighbours(of: Pos) = sequence { for (x in -1..1) for (y in -1..1) yield(Pair(x, y)) } .filterNot { (x, y) -\u0026gt; x == 0 \u0026amp;\u0026amp; y == 0 } .map { (x, y) -\u0026gt; Pos(of.x + x, of.y + y) } .filter { it.isValid() } fun simulateStep(): Int { val flashed = mutableSetOf\u0026lt;Pos\u0026gt;() tailrec fun flash(flash: Set\u0026lt;Pos\u0026gt;) { flashed += flash flash.toList().forEach { pos -\u0026gt; neighbours(pos).forEach { this[it] = this[it] + 1 } } if (flash.isNotEmpty()) flash(posOf[maxVal] - flashed) } indices.forEach { this[it] = this[it] + 1 } flash(posOf[maxVal]) indices.forEach { this[it] = this[it] % maxVal } return flashed.size } private fun Pos.isValid() = y in values.indices \u0026amp;\u0026amp; x in values[y].indices } Extra notes Let\u0026rsquo;s see that we solved each of the parts of the task on the copy of the input map. That\u0026rsquo;s because the map internal state is mutable (it changes during the simulation) but we need to have a fresh map when trying to solve the second part of the problem.\nWe used with Kotlin construct here, that simplified our code and introduced the context of current copy of EnergyMap. That\u0026rsquo;s one of the really cool Kotlin constructs that is in fact an inline function, so it brings no extra overhead on runtime while really simplifying our code.\nAlso in this day we introduced tests running with expected outputs of days. We used for it some tricky and simple function\n1 2 3 4 5 6 fun catchSystemOut(action: () -\u0026gt; Unit) = ByteArrayOutputStream().also { val originalOut = System.out System.setOut(PrintStream(it)) action() System.setOut(originalOut) }.toString() which is capable of catching the System.out value and returning it as simple String (that is later cmopared with the expected output in tests and Advent days are defined to print their solutions).\n","date":"2021-12-11T00:00:00Z","image":"https://procyk.in/post/advent-of-code-2021-11/featured_hu15517666098828018521.jpg","permalink":"https://procyk.in/post/advent-of-code-2021-11/","title":"Advent of Code 2021 in Kotlin - Day 11"},{"content":"Introduction The Day 10 problem is some modification of well known at Computer Science studies problem called Brackets Pairing for which we have to verify the given brackets expression. It\u0026rsquo;s valid if every type of parenthesis is closed after opening and the closing brackets matches the opening brackets as in standard math expressions.\nSolution We can easily solve this problem in linear memory using Stack\u0026lt;Char\u0026gt; structure to keep the characters representing opened brackets in already processed expression. So we need to\nRead current character Check if it\u0026rsquo;s opening or closing bracket If it\u0026rsquo;s an opening bracket, then push it to stack of history of characters If it\u0026rsquo;s a closing bracket, then pop the latest bracket from stack, find its closed alternative and check if it matches the current closing bracket It\u0026rsquo;s worth noticing that in stack we will always have only opening brackets as we push values to memory only for them (so our closed property of Char will never fail here).\nIn the first part we want to process the characters from every line until we find a corruption in data so not matching closed bracket. The firstOrNull seems to be the best choice here as it will stop searching for character as soon as it finds first.\nIn the second part we need to find the lines that are partially invalid i.e. there is no corrupted data but the data is unfinished. That means in our stack structure there will be left some brackets that were not matched during the process. We need to go through them and from the end and calculate the score, according to given rules. The simplest and most straightforward approach here is to use the foldRight extension function that allows us to accumulate some value and update it when iterating over some data from right to left (so from end to beginning).\nIt\u0026rsquo;s worth noting here that in case of Kotlin, foldRight is almost identical to fold (i.e. foldLeft) function because lists in Kotlin (and stacks too) are implemented as arrays, so we can iterate over them in any direction with the same constant cost in memory. In functional programming languages lists are represented usually as the head and the reference to the tail of the list - in such case processing lists from left to right is also cheap, but from right to left needs from us to build the whole stack of calls on list elements to get to the last element first and then to process the next elements in the reversed order.\nDay10.kt 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 import java.util.* object Day10 : AdventDay() { override fun solve() { val lines = reads\u0026lt;String\u0026gt;() ?: return lines.sumOf { it.corruptedScore() }.printIt() lines.mapNotNull { it.completionScore() }.sorted().let { it[it.size / 2] }.printIt() } } private val OPEN = setOf(\u0026#39;[\u0026#39;, \u0026#39;{\u0026#39;, \u0026#39;(\u0026#39;, \u0026#39;\u0026lt;\u0026#39;) private val CLOSE = setOf(\u0026#39;]\u0026#39;, \u0026#39;}\u0026#39;, \u0026#39;)\u0026#39;, \u0026#39;\u0026gt;\u0026#39;) private val Char.closed: Char? get() = when (this) { \u0026#39;{\u0026#39; -\u0026gt; \u0026#39;}\u0026#39; \u0026#39;(\u0026#39; -\u0026gt; \u0026#39;)\u0026#39; \u0026#39;[\u0026#39; -\u0026gt; \u0026#39;]\u0026#39; \u0026#39;\u0026lt;\u0026#39; -\u0026gt; \u0026#39;\u0026gt;\u0026#39; else -\u0026gt; null } private fun String.corruptedScore(): Int { val stack = Stack\u0026lt;Char\u0026gt;() val firstCorrupted = firstOrNull { c -\u0026gt; when (c) { in OPEN -\u0026gt; stack.push(c).let { false } in CLOSE -\u0026gt; stack.pop().closed != c else -\u0026gt; unknownBracket(c) } } return when (firstCorrupted) { \u0026#39;)\u0026#39; -\u0026gt; 3 \u0026#39;]\u0026#39; -\u0026gt; 57 \u0026#39;}\u0026#39; -\u0026gt; 1197 \u0026#39;\u0026gt;\u0026#39; -\u0026gt; 25137 else -\u0026gt; 0 } } private fun String.completionScore(): Long? { val stack = Stack\u0026lt;Char\u0026gt;() for (c in this) { when (c) { in OPEN -\u0026gt; stack.push(c) in CLOSE -\u0026gt; if (stack.pop().closed != c) return null else -\u0026gt; unknownBracket(c) } } return stack.foldRight(0L) { c, sum -\u0026gt; 5 * sum + when (c.closed) { \u0026#39;)\u0026#39; -\u0026gt; 1 \u0026#39;]\u0026#39; -\u0026gt; 2 \u0026#39;}\u0026#39; -\u0026gt; 3 \u0026#39;\u0026gt;\u0026#39; -\u0026gt; 4 else -\u0026gt; unknownBracket(c) } } } private fun unknownBracket(c: Char): Nothing = throw IllegalArgumentException(\u0026#34;Unknown bracket: $c\u0026#34;) Extra notes It\u0026rsquo;s worth noting how the unknownBracket function is implemented - it\u0026rsquo;s return type is Nothing what means in Kotlin that the control will never exit this function (function will return nothing) without throwing an exception. It\u0026rsquo;s the same way as the helper function TODO from standard library is defined.\n1 inline fun TODO(): Nothing = throw NotImplementedError() The purpose of such definition is to give the compiler the hint that it doesn\u0026rsquo;t have to take care of the value returned from the function (so also about the type of the value returned and doesn\u0026rsquo;t care about it when analyzing e.g. when expressions).\n","date":"2021-12-10T00:00:00Z","image":"https://procyk.in/post/advent-of-code-2021-10/featured_hu17834678558559728318.jpg","permalink":"https://procyk.in/post/advent-of-code-2021-10/","title":"Advent of Code 2021 in Kotlin - Day 10"},{"content":"Introduction The Day 9 problem requires from us searching through the defined heightmap. We can make it using commonly known algorithms for searching graphs where our graph can be seen as the positions from the map connected with each other if they are adjacent on map. Let\u0026rsquo;s see then how to implement the DFS and BFS search algorithms in Kotlin ðŸ”.\nSolution In order to get the answer for the first part of the problem it\u0026rsquo;s enough if for every position from our map, we filter the positions that are the low points and sum the values from map on these positions increased by 1 as stated in problem description.\nFor the second part, we define some useful search method that is capable of search the map in the DFS and BFS order. Usually we would write these algorithms with some recursive function that calls itself in order to visit siblings nodes.\nFor example, in case of DFS search, we could define\n1 2 3 4 5 6 7 8 fun dfs(from: Node, action: (Node) -\u0026gt; Unit = {}): Set\u0026lt;Node\u0026gt; { val visited = mutableSetOf\u0026lt;Node\u0026gt;() fun go(curr: Node) { visited += curr.also(action) neighbours(curr).filterNot { it in visited }.forEach { go(it) } } return visited.also { go(from) } } which would allow us to visit node, visit its first child, then the first child of first child etc. But we have to remember that for bigger data such definition would not work (and wouldn\u0026rsquo;t be really efficient) because calling function go brings some extra cost in space and time.\nIn such cases we usually define the iterative version of these algorithms that from my perspective may be harder to understand and keep clean in code. We could try to define such method in the following way\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 fun search( from: Node, type: SearchType = SearchType.DFS, action: (Node) -\u0026gt; Unit = {}, edge: (Node, Node) -\u0026gt; Boolean = { _, _ -\u0026gt; true } ): Set\u0026lt;Node\u0026gt; { val visited = mutableSetOf\u0026lt;Node\u0026gt;() val queue = ArrayDeque\u0026lt;Node\u0026gt;().apply { add(from) } while (true) { val curr = when (type) { SearchType.DFS -\u0026gt; queue.removeLastOrNull() ?: break SearchType.BFS -\u0026gt; queue.removeFirstOrNull() ?: break } visited += curr.also(action) neighbours(curr).filter { edge(curr, it) \u0026amp;\u0026amp; it !in visited }.forEach { queue += it } } return visited } where we see that the order of search depends on the order of removing elements from queue. You can look at it in the following way:\nfor DFS we inserted some sibling node to queue and the next node that we want to visit is this node so the last in the queue - let\u0026rsquo;s remove then the last element from queue and start searching from it (you can know it as Last-In, First-Out or LIFO order) for BFS, at first we want to add all siblings of current node to the queue and then start searching from the first node that was inserted in the past - let\u0026rsquo;s remove then the first element from queue and start searching from it (you can know it as First-In, First-Out or FIFO order) In Kotlin, we don\u0026rsquo;t have to use the while loop to express our intention of searching because it can be generated for us by the compiler. If we want to stay with the \u0026ldquo;recursive\u0026rdquo; approach that seems to be more readable for more people and have an efficient search algorithm, we can use the tailrec fun in Kotlin in the following way:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 fun search( from: Node, type: SearchType = SearchType.DFS, action: (Node) -\u0026gt; Unit = {}, edge: (Node, Node) -\u0026gt; Boolean = { _, _ -\u0026gt; true } ): Set\u0026lt;Node\u0026gt; { val visited = mutableSetOf\u0026lt;Node\u0026gt;() val queue = ArrayDeque\u0026lt;Node\u0026gt;() tailrec fun go(curr: Node) { visited += curr.also(action) neighbours(curr).filter { edge(curr, it) \u0026amp;\u0026amp; it !in visited }.forEach { queue += it } when (type) { SearchType.DFS -\u0026gt; go(queue.removeLastOrNull() ?: return) SearchType.BFS -\u0026gt; go(queue.removeFirstOrNull() ?: return) } } return visited.also { search(from) } } This definition will be translated to the loop as in previous example by Kotlin compiler, because all exits from inner go method are the tail calls of this method. It\u0026rsquo;s required that no transformation is done on the result of recursive call of function to name it a tail recursive function and to optimize its calls.\nDay9.kt 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 object Day9 : AdventDay() { override fun solve() { val map = reads\u0026lt;String\u0026gt;()?.toMap() ?: return map.indices.asSequence() .filter { p -\u0026gt; map.neighbours(of = p).all { map[it] \u0026gt; map[p] } } .sumOf { map[it] + 1 } .printIt() map.indices.asSequence() .map { p -\u0026gt; map.search(from = p) { from, to -\u0026gt; map[from] \u0026lt; map[to] \u0026amp;\u0026amp; map[to] != 9 } } .distinct().map { it.size } .sortedDescending().take(3) .fold(1, Int::times) .printIt() } } private fun List\u0026lt;String\u0026gt;.toMap() = Map(map { line -\u0026gt; line.map { it.digitToInt() } }) private data class Node(val x: Int, val y: Int) private data class Map\u0026lt;V\u0026gt;(val heights: List\u0026lt;List\u0026lt;V\u0026gt;\u0026gt;) { val indices = heights.flatMapIndexed { y, row -\u0026gt; row.indices.map { Node(it, y) } } operator fun get(p: Node): V = with(p) { heights[y][x] } fun neighbours(of: Node) = with(of) { sequenceOf( Node(x + 1, y), Node(x - 1, y), Node(x, y + 1), Node(x, y - 1) ).filter { it.isValid() } } enum class SearchType { DFS, BFS } fun search( from: Node, type: SearchType = SearchType.DFS, action: (Node) -\u0026gt; Unit = {}, visit: (Node, Node) -\u0026gt; Boolean = { _, _ -\u0026gt; true } ): Set\u0026lt;Node\u0026gt; { val visited = mutableSetOf\u0026lt;Node\u0026gt;() val queue = ArrayDeque\u0026lt;Node\u0026gt;() tailrec fun go(curr: Node) { visited += curr.also(action) neighbours(curr).filter { visit(curr, it) \u0026amp;\u0026amp; it !in visited }.forEach { queue += it } when (type) { SearchType.DFS -\u0026gt; go(queue.removeLastOrNull() ?: return) SearchType.BFS -\u0026gt; go(queue.removeFirstOrNull() ?: return) } } return visited.also { go(from) } } private fun Node.isValid() = y in heights.indices \u0026amp;\u0026amp; x in heights[y].indices } Extra notes Let\u0026rsquo;s see how we defined the fun Pos.isValid(). It\u0026rsquo;s a private function in the class Map which is an extension of Pos class. Thanks to such approach we could call it without specifying the receiver explicitly, but rather using this as implicit receiver. It\u0026rsquo;s the most common approach to do this for private function because they all can be called only inside the class implementation so the this receiver of outer class doesn\u0026rsquo;t have to be defined explicitly.\nNotice also the definition of indices property of our Map - it\u0026rsquo;s a good practice to create functions and properties that are similar to the definitions from the standard library (not only in Kotlin but Kotlin provides us really consistent standard library naming).\n","date":"2021-12-09T00:00:00Z","image":"https://procyk.in/post/advent-of-code-2021-9/featured_hu13426754888128919086.jpg","permalink":"https://procyk.in/post/advent-of-code-2021-9/","title":"Advent of Code 2021 in Kotlin - Day 9"},{"content":"Introduction The Day 8 problem is given with really long description that may frighten the reader at first. It explains the definition of 7-segment display which is commonly used in electronics and how its segments are ordered. What\u0026rsquo;s more important, it contains also some hints how we can look at the problem and what should be done to distinguish the digits from input.\nSolution The first part of the problem is pretty straightforward so probably doesn\u0026rsquo;t need extra explanation.\nThe second part needs some deeper deduction that may require some explanation. What we vat to find in this part is to map the numbers shuffled representations to numbers (where all of them are shuffled in the same manner).\nAs stated in the problem description, we can deduce which are 1, 4, 7 and 8 numbers as they are build with the unique number of segments (respectively 2, 4, 3 and 7).\nNext we can notice that the other numbers are built of 5 or 6 segments. So we can process every group separately and try to deuce each number using some helper function extract.\n1 2 fun MutableSet\u0026lt;Digit\u0026gt;.extract(by: Digit, diff: Int) = single { (it - by).segments.size == diff }.also { this -= it } It takes the set of digits where all of them have the same number of segments and then finds the single digit for which, after removing the segments from set by, the number of segments is equal to diff. After that it also modifies the set of numbers by removing the returned digit from it.\nFirst we notice, that for the numbers from group built of 5 segments when we remove the segments from 1, we will get only one set of segments of size 3, and it will correspond to the rest of the digit 3. So we write that\n1 val three = fiveSeg.extract(one, 3) and then also notice that for the rest of the numbers from set fiveSeg if we remove the segments from 4, we will get only one set of segments of size 3, that will correspond to the rest of digit 2, so we get\n1 val two = fiveSeg.extract(four, 3) and the only five segments digits that is left unprocessed is 5, so we can write\n1 val five = fiveSeg.single() The same process can be applied to the set of numbers that are built of 6 segments and we do it accordingly in code by\n1 2 3 4 val sixSeg = seg[6]!!.toMutableSet() val nine = sixSeg.extract(four, 2) val six = sixSeg.extract(one, 5) val zero = sixSeg.single() In this way we found the whole encoding of the numbers that can be returned as the map from digit representation to each of numbers from 0 to 9. Next, it\u0026rsquo;s enough to use this mapping and decode the outputs from the entry. We use fold here to calculate the number that is represented by the following digits - it\u0026rsquo;s not only much faster than working on strings or characters and calling the toInt function on the concatenated value, but also gives us the ability to practice the fold usage in action ðŸ˜‰.\nDay8.kt 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 object Day8 : AdventDay() { override fun solve() { val positions = reads\u0026lt;String\u0026gt;()?.map { it.toDigitsEntry() } ?: return positions.sumOf { it.outputs.count(Digit::isEasy) }.printIt() positions.sumOf { it.decode() }.printIt() } } private fun String.toDigitsEntry() = split(\u0026#34; | \u0026#34;).map { part -\u0026gt; part.split(\u0026#34; \u0026#34;).map { Digit(it.toSet()) } }.let { (input, output) -\u0026gt; DigitsEntry(input, output) } private data class Digit(val segments: Set\u0026lt;Char\u0026gt;) { val isEasy = segments.size in setOf(2, 3, 4, 7) operator fun minus(o: Digit) = Digit(segments - o.segments) } private data class DigitsEntry(val inputs: List\u0026lt;Digit\u0026gt;, val outputs: List\u0026lt;Digit\u0026gt;) { fun decode(): Int = deduce().let { enc -\u0026gt; outputs.fold(0) { acc, dig -\u0026gt; 10 * acc + enc[dig]!! } } private fun deduce(): Map\u0026lt;Digit, Int\u0026gt; { val seg = inputs.toSet().groupBy { it.segments.size } val one = seg[2]!!.single() val four = seg[4]!!.single() val seven = seg[3]!!.single() val eight = seg[7]!!.single() fun MutableSet\u0026lt;Digit\u0026gt;.extract(by: Digit, diff: Int) = single { (it - by).segments.size == diff }.also { this -= it } val fiveSeg = seg[5]!!.toMutableSet() val three = fiveSeg.extract(one, 3) val two = fiveSeg.extract(four, 3) val five = fiveSeg.single() val sixSeg = seg[6]!!.toMutableSet() val nine = sixSeg.extract(four, 2) val six = sixSeg.extract(one, 5) val zero = sixSeg.single() return listOf(zero, one, two, three, four, five, six, seven, eight, nine) .zip(0..9).toMap() } } Extra notes Notice that we defined some operator fun for Digit class that is in Kotlin the implementation of the operator overloading. We define the subtract operation for this class as a difference of their sets of segments. In this way we can express our intention in Kotlin code more efficiently, using usually more readable operator syntax in different places, as we did in the definition of extract - it was so obvious what it is that you could even not notice that it\u0026rsquo;s an overloaded operator used in this place ðŸ˜Ž.\n","date":"2021-12-08T00:00:00Z","image":"https://procyk.in/post/advent-of-code-2021-8/featured_hu12295921270248995848.jpg","permalink":"https://procyk.in/post/advent-of-code-2021-8/","title":"Advent of Code 2021 in Kotlin - Day 8"},{"content":"Introduction The Day 7 problem can be solved using bruteforce solution and searching in all possible numbers to find the minimal amount of fuel needed. However, we would like to present some known properties from statistics that can make our solution faster ðŸ˜Ž.\nSolution We\u0026rsquo;re given a list of positions $X = \\lbrace x_1, x_2, \\ldots, x_n \\rbrace$ for which we have to find some position $y_c$ according to the specified cost function $c$ that will minimize\n$$\\sum_{i=1}^{n} c(x_i, y_c)$$\nso we can write that\n$$y_c = \\underset{x}{\\textnormal{argmin}} \\sum_{i=1}^{n} c(x_i, x)$$\nIn the first part we have to find the position $y_m$ that minimizes\n$$\\sum_{i=1}^{n} |x_i - y_m|$$\nwhich is known to be minimized by median value from $X$ ðŸ˜®.\nThat\u0026rsquo;s it - we don\u0026rsquo;t need to check all values from range $[ 0, \\textnormal{max }X]$. It\u0026rsquo;s enough if your remember that property as it can be useful, while proving it cannot be presented easily.\nIn the second part we have to find the position $y_a$ that minimizes\n$$\\sum_{i=1}^{n} \\sum_{j=1}^{|x_i - y_a|} j = \\sum_{i=1}^{n} \\frac{|x_i - y_a| (|x_i - y_a| + 1)}{2}$$\nI don\u0026rsquo;t know how to minimize that sum directly, but for the purpose of the task I tried to minimize just the sum\n$$\\sum_{i=1}^{n} \\frac{|x_i - y_a|^2}{2}=\\sum_{i=1}^{n} \\frac{(x_i - y_a)^2}{2}$$\nfor which we can calculate the derivative directly and compare it to $0$ to notice that this function have its minimum for $y_m = \\frac{1}{n} \\sum_{i=1}^{n} x_i$ i.e. the average of numbers from $X$.\nIt\u0026rsquo;s enough in case of this problem to find such approximation of the solution as we deal with natural numbers so changing value some number by $1$ is pretty small change so it shouldn\u0026rsquo;t change the final result - that\u0026rsquo;s only my intuition, but it seems to work in case of this problem as I have tested the solution, and I haven\u0026rsquo;t found bad cases yet.\nI hope these properties of numbers may be useful for you at some day ðŸ¤ž.\nDay7.kt 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 import kotlin.math.abs import kotlin.math.ceil import kotlin.math.floor object Day7 : AdventDay() { override fun solve() { val positions = reads\u0026lt;String\u0026gt;()?.singleOrNull() ?.separated\u0026lt;Int\u0026gt;(by = \u0026#34;,\u0026#34;) ?: return positions.median() .let { positions.absCost(it) } .printIt() positions.average() .let { sequenceOf(floor(it), ceil(it)) } .map { it.toInt() } .minOf { positions.incrCost(it) } .printIt() } } private fun List\u0026lt;Int\u0026gt;.absCost(from: Int) = sumOf { to -\u0026gt; abs(from - to) } private fun List\u0026lt;Int\u0026gt;.incrCost(from: Int) = sumOf { to -\u0026gt; abs(from - to) * (abs(from - to) + 1) / 2 } private fun List\u0026lt;Int\u0026gt;.median() = sorted() .run { (this[(size - 1) / 2] + this[size / 2]) / 2 } Extra notes We introduced pretty new function for dealing with input data when solving this day problem.\n1 2 inline fun \u0026lt;reified T\u0026gt; String.separated(by: String): List\u0026lt;T\u0026gt; = split(by).map { it.value() } It is intended to use with named parameter - that\u0026rsquo;s the convention partially introduced to Kotlin that is quite popular in Swift and allows us to read code directly, e.g.\n1 \u0026#34;1,2,3\u0026#34;.separated\u0026lt;Int\u0026gt;(by = \u0026#34;,\u0026#34;) is simply seen as \u0026ldquo;List of Int separated by \u0026quot;,\u0026quot;\u0026rdquo; - keep this in mind when designing your api in Kotlin to make it more readable in many cases ðŸ˜‰.\n","date":"2021-12-07T00:00:00Z","image":"https://procyk.in/post/advent-of-code-2021-7/featured_hu16563043185040118260.jpg","permalink":"https://procyk.in/post/advent-of-code-2021-7/","title":"Advent of Code 2021 in Kotlin - Day 7"},{"content":"Introduction The Day 6 problem shows how important proper representation of problem is. The natual way of solving this problem doesn\u0026rsquo;t work in the second part as it would produce exponential size of data. Let\u0026rsquo;s see then how quickly this problem can be solved and how we can deal with immutable data in Kotlin.\nSolution We define the afterDay function for LanternFish which returns fish after single day as new objects. This approach is commonly used in functional programming, when dealing with immutable data - we don\u0026rsquo;t modify the internal state of objects, but instead we return some new objects with modified internal state. In this way our code becomes more readable because we can assume immutability of the objects. The same assumption is applied to FishShoal for its afterDays function. However, in this approach we have to use fold function to write the simulation of shoal state (and not to use some additional local variable).\nIn our solution we keep counts of every \u0026ldquo;type\u0026rdquo; of fish in shoal using some internal map counts. Instead of just keeping all fish on some list, we can notice that there is a limited number of types of fish, because fish can have timer with only limited values. That\u0026rsquo;s enough to solve this problem efficiently and get the result in less than one second.\nDay6.kt 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 object Day6 : AdventDay() { override fun solve() { val shoal = reads\u0026lt;String\u0026gt;()?.singleOrNull()?.toFishShoal() ?: return shoal.afterDays(80).size.printIt() shoal.afterDays(256).size.printIt() } } private fun String.toFishShoal() = split(\u0026#34;,\u0026#34;).map { LanternFish(it.toInt()) } .groupingBy { it }.eachCount().mapValues { it.value.toLong() } .let { FishShoal(it) } private data class LanternFish(private val timer: Int) { fun afterDay(): List\u0026lt;LanternFish\u0026gt; = when (val nextTimer = timer - 1) { -1 -\u0026gt; listOf(LanternFish(6), LanternFish(8)) else -\u0026gt; listOf(LanternFish(nextTimer)) } } private class FishShoal(val counts: Map\u0026lt;LanternFish, Long\u0026gt;) { val size = counts.values.sum() fun afterDays(days: Int = 1) = (1..days).fold(this) { shoal, _ -\u0026gt; shoal.afterDay() } private fun afterDay(): FishShoal = DefaultMap\u0026lt;LanternFish, Long\u0026gt;(0).also { counts.forEach { (fish, count) -\u0026gt; fish.afterDay().forEach { newFish -\u0026gt; it[newFish] = it[newFish] + count } } }.let { FishShoal(it) } } Extra notes Let\u0026rsquo;s notice that it was only one day, and we used the DefaultMap\u0026lt;K, V\u0026gt; again in our code. That made my day - it shows how useful was the definition of this helper and that it can be useful also in some future problems ðŸ˜Ž.\nWhat\u0026rsquo;s worth noting here is the Kotlin way to express counting after grouping objects by som property (that was used in toFishShoal definition). We can try to generalize that function as\n1 2 inline fun \u0026lt;T, K\u0026gt; Iterable\u0026lt;T\u0026gt;.countGroupingBy(crossinline keySelector: (T) -\u0026gt; K) = groupingBy(keySelector).eachCount() which can later be used for example as\n1 listOf(1, 3, 4, 2, 2, 1).countGroupingBy { it } in order to count the number of occurrences of object on list. We should pay extra attention here to the crossinline modifier and understanding what it does in Kotlin code.\nWell, it\u0026rsquo;s stated in documentation that when the lambda parameter of the inline function is defined as crossinline, then this parameter cannot use non-local returns. What that means in practice is we cannot use some return in the crossinline lambda body that would cause jump out of some outer scope.\nUsing some good example, we can look at the definition of function from standard library, e.g.\n1 2 3 inline fun \u0026lt;T\u0026gt; Iterable\u0026lt;T\u0026gt;.forEach(action: (T) -\u0026gt; Unit): Unit { for (element in this) action(element) } For this function, the action parameter is not defined as crossinline so there are two types of returns from action allowed.\nThe first one is the local return that causes jumping out of the execution of the action lambda, so when we use it in the following way\n1 2 3 4 5 6 7 fun main() { listOf(1, 2, 3).forEach { if (it % 2 == 0) return@forEach println(it) } println(\u0026#34;After forEach\u0026#34;) } we can see printed out to the console\n1 2 3 1 3 After forEach because we jumped out from printing action for it == 2.\nIn the next situation when \u0026ldquo;standard\u0026rdquo; return instruction is used\n1 2 3 4 5 6 7 fun main() { listOf(1, 2, 3).forEach { if (it % 2 == 0) return println(it) } println(\u0026#34;After forEach\u0026#34;) } we get\n1 1 as program result in the stdout as we jumped out from the main for it == 2.\nWe can see with these examples that the second return caused jumping out of the main function, while return@forEach finishes only execution of single action.\nIf we used the crossinline modifier for action parameter, then the second construct would be forbidden. Yes, that\u0026rsquo;s so simple and allows us to express our intention what the action should be capable of doing, when designing some functions.\nI hope these examples show more clearly how this modifier works and when could be used in our code - it\u0026rsquo;s somehow tricky because it\u0026rsquo;s hard to find a good example on the Internet but by playing with the language we can learn how it really works and why it was introduced to the language âœŒ.\n","date":"2021-12-06T00:00:00Z","image":"https://procyk.in/post/advent-of-code-2021-6/featured_hu15741248874657872933.jpg","permalink":"https://procyk.in/post/advent-of-code-2021-6/","title":"Advent of Code 2021 in Kotlin - Day 6"},{"content":"Introduction The Day 5 problem is the next one that can be really simple expressed using object-oriented programming techniques. To solve it, we propose some tricky Kotlin definitions for helpers that are really useful in the implementation of marking lines on the diagram.\nHelper definitions Generic DefaultMap\u0026lt;K, V\u0026gt; We start with the pretty simple but really helpful definition of DefaultMap in Kotlin in just a few lines\n1 2 3 4 5 6 class DefaultMap\u0026lt;K, V\u0026gt;( private val default: V, private val map: MutableMap\u0026lt;K, V\u0026gt; = HashMap() ) : MutableMap\u0026lt;K, V\u0026gt; by map { override fun get(key: K): V = map.getOrDefault(key, default).also { map[key] = it } } In this short definition we have realized the whole implementation of MutableMap\u0026lt;K, V\u0026gt; interface as most of the functionalities are delegated to selected map that is a backing field in our implementation and can be customized if needed. What we can do more is even creating some lazy generator for default values - it wasn\u0026rsquo;t needed in today problem so was not written in this way. Anyway, the most important thing is to notice and remember that in Kotlin we don\u0026rsquo;t need to implement some functionalities from implemented interfaces because we can delegate the implementation to some specified objects that are able to realize given functionality with only single keyword by.\nAlways working IntProgression For standard ranges in Kotlin we have a restriction that it has to start on smaller value and finish on bigger or equal (just because in other case it\u0026rsquo;s empty). That makes a lot of sense when we define such ranges statically, using some values for which the order is known at compile time. The same applies for descending IntProgression that can be defined with downTo infix function.\nIn our case we don\u0026rsquo;t know if we should use rangeTo (i.e. .. operator) or downTo for points coordinates, so we can define some small but really useful helper function that can be represented as infix function\n1 infix fun Int.directedTo(o: Int) = if (this \u0026lt;= o) this..o else this downTo o that returns not empty IntProgression for any pair of points.\nSolution We represent the points and lines as P and L data classes for simplicity of code. They are quite readable and allows us to keep the counts of marked points in Map\u0026lt;P, Int\u0026gt; because the hashCode and equals implementation are automatically generated for data classes in Kotlin.\nMoreover, in the implementation of diagram we use some baking field to count the marked points as _m and then expose it as property of type Map\u0026lt;P, Int\u0026gt;. That\u0026rsquo;s because in Kotlin the mutability of collections is checked at compile time, based on their types, so in this way we can restrict mutability of _m outside of Diagram.\nDay5.kt 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 import kotlin.math.abs object Day5 : AdventDay() { override fun solve() { val lines = reads\u0026lt;String\u0026gt;()?.map { it.toLine() } ?: return Diagram().apply { lines.filter { it.isVertical || it.isHorizontal }.forEach { markLine(it) } marked.count { it.value \u0026gt; 1 }.printIt() } Diagram().apply { lines.forEach { markLine(it) } marked.count { it.value \u0026gt; 1 }.printIt() } } } private data class P(val x: Int, val y: Int) private data class L(val from: P, val to: P) { val isHorizontal = from.x == to.x val isVertical = from.y == to.y val isDiagonal = abs(from.y - to.y) == abs(from.x - to.x) } private fun String.toLine() = split(\u0026#34; -\u0026gt; \u0026#34;).map { p -\u0026gt; p.split(\u0026#34;,\u0026#34;).let { (x, y) -\u0026gt; P(x.toInt(), y.toInt()) } }.let { (f, t) -\u0026gt; L(f, t) } private class Diagram { private val _m = DefaultMap\u0026lt;P, Int\u0026gt;(0) val marked: Map\u0026lt;P, Int\u0026gt; = _m fun markLine(line: L) = with(line) { when { isVertical -\u0026gt; (from.x directedTo to.x).map { P(it, to.y) } .forEach { _m[it] = _m[it] + 1 } isHorizontal -\u0026gt; (from.y directedTo to.y).map { P(to.x, it) } .forEach { _m[it] = _m[it] + 1 } isDiagonal -\u0026gt; (from.x directedTo to.x).zip(from.y directedTo to.y) .map { (x, y) -\u0026gt; P(x, y) } .forEach { _m[it] = _m[it] + 1 } else -\u0026gt; Unit } } } Extra notes What\u0026rsquo;s worth noting in this code too, are two usages of standard library inline functions i.e. with and apply. Both of them are used to simplify the statements with removing all calls to Diagram() or line as they become this receiver. As mentioned, these are the inline functions so this brings no overhead for execution - it\u0026rsquo;s just more readable code that allows use to simply select the methods called on some objects ðŸ˜.\n","date":"2021-12-05T00:00:00Z","image":"https://procyk.in/post/advent-of-code-2021-5/featured_hu11471720896330469766.jpg","permalink":"https://procyk.in/post/advent-of-code-2021-5/","title":"Advent of Code 2021 in Kotlin - Day 5"},{"content":"Introduction The Day 4 problem describes the simulation of Bingo game. While the rules of the game are widely known and the simulation of the game is not so hard, it turns out that the main point of the solution is to efficiently parse and represent the given data, to come up with some nice solution for the problem. Let\u0026rsquo;s begin then with some useful Kotlin concepts and helper functions ðŸ˜Š.\nHelper functions We define two main helpers that seems to be useful in the future tasks as they solve some general problems in pretty efficient way.\nTranspose List\u0026lt;List\u0026lt;T\u0026gt;\u0026gt; Flipping rows with columns of 2D array of list requires equal sizes of each row of data. We need to check that before processing the collection and then the transpose of List\u0026lt;List\u0026lt;T\u0026gt;\u0026gt; can be written in Kotlin in one simple line of code with no extra performance overhead - just generate new collection of collections with lambdas that use the original collection in pretty straightforward way - flipping $x$ and $y$ axes of values from matrix (i.e. List\u0026lt;List\u0026lt;T\u0026gt;\u0026gt;).\n1 2 3 4 5 fun \u0026lt;T\u0026gt; List\u0026lt;List\u0026lt;T\u0026gt;\u0026gt;.transpose(): List\u0026lt;List\u0026lt;T\u0026gt;\u0026gt; { val n = map { it.size }.toSet().singleOrNull() ?: throw IllegalArgumentException(\u0026#34;Invalid data to transpose: $this\u0026#34;) return List(n) { y -\u0026gt; List(size) { x -\u0026gt; this[x][y] } } } Group data separated by value This transformation is usually required when the data is separated with empty lines and single group of lines should be processed together. In today\u0026rsquo;s task we\u0026rsquo;re given a list of strings that represents the board games, but every board is represented with multiple lines and separated with empty line from other boards.\nWe can try to implement such functionality with Sequence\u0026lt;V\u0026gt; builder that is later collected to List\u0026lt;V\u0026gt; in single call. We use it because it allows to yield the result only at certain moments - in our case when the description of the board finishes, and we have accumulated the description of the last board, we yield our current result.\nNotice that we use some var to keep the current value of accumulated value that is later yield after some transformation. It\u0026rsquo;s worth mentioning here how the variables caught by lambda scopes works in Kotlin as it\u0026rsquo;s quite different from other languages - when we deal with mutable var it remains mutable in the captured scope of the lambda and the assignments executed in scope of the lambda are visible outside. It\u0026rsquo;s really useful technique when we define some nested functions and don\u0026rsquo;t want to pass its state in the variable - we can just define it before function definitions and use later as it\u0026rsquo;d be given as function\u0026rsquo;s parameter.\nWhat I\u0026rsquo;ve learned when writing this helper function is the restriction for the yield function calls that have to be defined directly inside the SequenceScope\u0026lt;T\u0026gt;, so we cannot define some helper function inside the sequence { } builder and use yield in it. One may ask then, why using forEach is then allowed here if it defines some lambda function too? The answer is somehow surprising but didactic - this function is defined with inline modifier, so it\u0026rsquo;s translated to direct call of the code of the for loop (as stated in its definition). Remember then, that if you find some unexpected pattern from top level perspective in your bytecode, it\u0026rsquo;s probably caused by inlining a few functions' calls definitions from standard library ðŸ˜‰.\n1 2 3 4 5 6 7 8 9 10 11 12 fun \u0026lt;U, V\u0026gt; List\u0026lt;U\u0026gt;.groupDividedBy( separator: U, transform: (List\u0026lt;U\u0026gt;) -\u0026gt; V ): List\u0026lt;V\u0026gt; = sequence { var curr = mutableListOf\u0026lt;U\u0026gt;() forEach { if (it == separator \u0026amp;\u0026amp; curr.isNotEmpty()) yield(transform(curr)) if (it == separator) curr = mutableListOf() else curr += it } if (curr.isNotEmpty()) yield(transform(curr)) }.toList() Solution We present some quite general solution that is not the post performant but seems to be one of the most readable ones seen today. That\u0026rsquo;s because we define some general function simulateSelectingFirst for a game that allows to simply define the strategy for selecting winning board during the simulation.\nAdditionally, parsing the data lines has become really readable with created helper functions. We use them also for transposing the data of the board to be able to check for bingo easily. The cost of checking for bingo is proportional to size of the board but the boards are tiny. If we would like to implement this in more efficient way, we should count marked values for each row and each column and check, if it\u0026rsquo;s big enough for bingo.\nDay4.kt 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 object Day4 : AdventDay() { override fun solve() { val lines = reads\u0026lt;String\u0026gt;() ?: return val game = Game(lines.extractOrder(), lines.extractBoards()) game.simulateSelectingFirst { board -\u0026gt; board.wins() } ?.let { (b, v) -\u0026gt; b.unmarkedValues().sum() * v }.printIt() val leftBoards = game.boards.toMutableSet() game.simulateSelectingFirst { board -\u0026gt; if (board.wins()) leftBoards -= board leftBoards.isEmpty() }?.let { (b, v) -\u0026gt; b.unmarkedValues().sum() * v }.printIt() } private fun List\u0026lt;String\u0026gt;.extractOrder() = firstOrNull()?.split(\u0026#34;,\u0026#34;)?.map { it.value\u0026lt;Int\u0026gt;() } ?: throw IllegalArgumentException(\u0026#34;No order defined in data: $this\u0026#34;) private fun List\u0026lt;String\u0026gt;.extractBoards() = drop(1).groupSeparatedBy(\u0026#34;\u0026#34;) { it.toBoard\u0026lt;Int\u0026gt;() } } private class Game\u0026lt;V\u0026gt;(val order: List\u0026lt;V\u0026gt;, val boards: List\u0026lt;Board\u0026lt;V\u0026gt;\u0026gt;) { fun simulateSelectingFirst(strategy: (Board\u0026lt;V\u0026gt;) -\u0026gt; Boolean): Pair\u0026lt;Board\u0026lt;V\u0026gt;, V\u0026gt;? { for (v in order) { boards.forEach { it.mark(v) } boards.firstOrNull(strategy)?.let { return Pair(it, v) } } return null } } private inline fun \u0026lt;reified V\u0026gt; List\u0026lt;String\u0026gt;.toBoard() = map { line -\u0026gt; line.splitToSequence(\u0026#34;\\\\s+\u0026#34;.toRegex()) .filter { it.isNotBlank() } .mapTo(mutableListOf()) { it.value\u0026lt;V\u0026gt;() } }.let { Board(it) } private class Board\u0026lt;V\u0026gt;(private val values: List\u0026lt;List\u0026lt;V\u0026gt;\u0026gt;) { private val transposedValues = values.transpose() private val markedValues = mutableSetOf\u0026lt;V\u0026gt;() private val allValues = values.flatten() fun mark(value: V) = markedValues.add(value) fun wins() = values.rowWins() || transposedValues.rowWins() fun unmarkedValues() = allValues - markedValues private fun List\u0026lt;List\u0026lt;V\u0026gt;\u0026gt;.rowWins() = any { row -\u0026gt; row.all { it in markedValues } } } Extra notes Let\u0026rsquo;s see how the Board\u0026lt;V\u0026gt; is represented in the solution. It contains a copy of values in transposed order to check for the bingo as described above. What\u0026rsquo;s more interesting , it contains some extension function fun List\u0026lt;List\u0026lt;V\u0026gt;\u0026gt;.rowWins() that has access to the field of the class. In this way we define the function that has to be called in the context of specified object (in this case this can only be Board\u0026lt;V\u0026gt; context but the same context applies in DSL design in Kotlin). It\u0026rsquo;s a gorgeous way of expressing some intentions for functions when it can have a few contexts (so almost a few this receivers). You can read more about it in KEEP 259 discussion to see what cool features are going to be introduced to Kotlin in some future releases ðŸ™ƒ.\n","date":"2021-12-04T00:00:00Z","image":"https://procyk.in/post/advent-of-code-2021-4/featured_hu2641059763097923032.jpg","permalink":"https://procyk.in/post/advent-of-code-2021-4/","title":"Advent of Code 2021 in Kotlin - Day 4"},{"content":"Introduction The Day 3 problem seems to be quite harder than the previous ones as it requires understanding the whole task before trying to implement the solution. Read the task description by yourself and try to abstract the common functionalities from it to see, how hard this process can be at the beginning.\nSolution In both parts of the tasks we can see some similar transformations of input date when calculating required rates and ratings. For calculating gamma rate and epsilon rate, as well as for calculating the $O_2$ rating and $CO_2$ rating we can notice that they can be abstracted with some predicate value that filters the counts of ones and zeros on every position.\nDay3.kt 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 object Day3 : AdventDay() { override fun solve() { val numbers = reads\u0026lt;String\u0026gt;() ?: return val n = numbers.commonLength() val zerosOnes = numbers.countZerosOnes(n) val gammaRate = zerosOnes.calcRate { zeros, ones -\u0026gt; ones \u0026gt; zeros } val epsilonRate = zerosOnes.calcRate { zeros, ones -\u0026gt; ones \u0026lt; zeros } (gammaRate * epsilonRate).printIt() val o2Rating = numbers.calculateRating(n) { zeros, ones -\u0026gt; zeros \u0026lt;= ones } val co2Rating = numbers.calculateRating(n) { zeros, ones -\u0026gt; zeros \u0026gt; ones } (o2Rating * co2Rating).printIt() } private fun List\u0026lt;String\u0026gt;.commonLength() = map { it.length }.toSet().singleOrNull() ?: throw IllegalArgumentException(\u0026#34;No common length for list of strings: $this\u0026#34;) private fun List\u0026lt;String\u0026gt;.countZerosOnes(n: Int) = listOf(\u0026#39;0\u0026#39;, \u0026#39;1\u0026#39;) .map { c -\u0026gt; List(n) { idx -\u0026gt; count { it[idx] == c } } } .let { (zeros, ones) -\u0026gt; zeros.zip(ones) } private fun List\u0026lt;Pair\u0026lt;Int, Int\u0026gt;\u0026gt;.calcRate( predicate: (Int, Int) -\u0026gt; Boolean ) = map { (zeros, ones) -\u0026gt; if (predicate(zeros, ones)) \u0026#39;1\u0026#39; else \u0026#39;0\u0026#39; }.joinToString(\u0026#34;\u0026#34;).toInt(radix = 2) private fun List\u0026lt;String\u0026gt;.calculateRating( n: Int, predicate: (Int, Int) -\u0026gt; Boolean ): Int = toMutableList().apply { for (idx in 0 until n) { if (size == 1) break val (zeros, ones) = countZerosOnes(n)[idx] val commonValue = if (predicate(zeros, ones)) \u0026#39;1\u0026#39; else \u0026#39;0\u0026#39; removeIf { it[idx] != commonValue } } }.single().toInt(radix = 2) } Extra notes When analyzing presented solution you can notice that it\u0026rsquo;s not optimal in terms of time complexity of the algorithm used. It\u0026rsquo;s mainly because in the second part we use countZerosOnes function in every loop execution to calculate number of zeros and ones for the remaining list of input binary numbers. We can do this because the given dataset is not so huge (1000 lines of data) so even the quadratic solution would be good as the length of the lines $n$ is pretty small. In my opinion that\u0026rsquo;s the most important lesson form this task - think first what is required for your solution and for what kind of data it\u0026rsquo;s expected to work. Sometimes, it\u0026rsquo;s better to write more readable code that works slower instead of trying to get the best performance and make the code not editable by others ðŸ™ˆ.\n","date":"2021-12-03T00:00:00Z","image":"https://procyk.in/post/advent-of-code-2021-3/featured_hu5113218346081419190.jpg","permalink":"https://procyk.in/post/advent-of-code-2021-3/","title":"Advent of Code 2021 in Kotlin - Day 3"},{"content":"Introduction The Day 2 problem can be solved in pretty straightforward way, but let\u0026rsquo;s try to express our solution in the way, that would make the code most readable in functional style.\nQuick notes In my solution I wanted to focus on the functional coding style in Kotlin and the well known from functional languages function fold which can be seen as foldLeft function from other languages. Its role is to iterate over the specified collection of items, using some accumulator to hold the current result and return this result at the end.\nIn my opinion, if you don\u0026rsquo;t understand what\u0026rsquo;s the purpose of some function from standard library, the easiest approach is to look into its source to analyze its behavior (what can be easily done with Ctrl + B shortcut in Intellij). Let\u0026rsquo;s see then at the definition of fold\n1 2 3 4 5 inline fun \u0026lt;T, R\u0026gt; Iterable\u0026lt;T\u0026gt;.fold(init: R, f: (acc: R, T) -\u0026gt; R): R { var acc = init for (element in this) acc = f(acc, element) return acc } which now should be obvious how it works. If you have problem with seeing the way of applying it, you should think what is actually your current result (represented by acc) and how you extend this current value to the state after processing one more element from collection (which is realized with transformation f).\nIt needs some time to get used to such approach, but you get some benefits with it - your code becomes more declarative and expresses your intention directly, because you write only what\u0026rsquo;s the initial state and how to transform current state to the next one, and the whole processing is done with your transformation.\nWhat\u0026rsquo;s worth mentioning here is the inline keyword before this and many, many more functions from standard library in Kotlin - this code compiled and disassembled can be seen as old-style loop over items that you probably would write in place of calling the fold - so we get this readability in our cost with no overhead for performance in execution ðŸ˜.\nSolution The solution to the problem was implemented according to the description oof the task - the code is more readable thanks to using sealed interface Cmd that we parse only once (with fun String.cmd()) and then use as typed value.\nThe whole logic is contained in single when expression that allows us to define mentioned transformation of current result. As an accumulator we keep the values (x, y) or (x, y, aim) and accordingly transform them.\nDay2.kt 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 object Day2 : AdventDay() { override fun solve() { val commands = reads\u0026lt;String\u0026gt;()?.map { it.cmd() } ?: return commands.calcPosition().run { first * second }.printIt() commands.calcAimedPosition().run { first * second }.printIt() } private fun List\u0026lt;Cmd\u0026gt;.calcPosition() = fold(Pair(0, 0)) { (x, y), (dir, v) -\u0026gt; when (dir) { Forward -\u0026gt; Pair(x + v, y) Down -\u0026gt; Pair(x, y + v) Up -\u0026gt; Pair(x, y - v) } } private fun List\u0026lt;Cmd\u0026gt;.calcAimedPosition() = fold(Triple(0, 0, 0)) { (x, y, a), (dir, v) -\u0026gt; when (dir) { Down -\u0026gt; Triple(x, y, a + v) Up -\u0026gt; Triple(x, y, a - v) Forward -\u0026gt; Triple(x + v, y + a * v, a) } } } private data class Cmd(val dir: Dir, val v: Int) private sealed interface Dir private object Forward : Dir private object Up : Dir private object Down : Dir private fun String.cmd() = split(\u0026#34; \u0026#34;).takeIf { it.size == 2 }?.let { (dir, v) -\u0026gt; when (dir) { \u0026#34;forward\u0026#34; -\u0026gt; Cmd(Forward, v.toInt()) \u0026#34;up\u0026#34; -\u0026gt; Cmd(Up, v.toInt()) \u0026#34;down\u0026#34; -\u0026gt; Cmd(Down, v.toInt()) else -\u0026gt; throw IllegalArgumentException(\u0026#34;Unknown direction specified in data: $dir\u0026#34;) } } ?: throw IllegalArgumentException(\u0026#34;Invalid data format\u0026#34;) Extra notes It\u0026rsquo;s worth seeing how we implement also the fun String.cmd() as it contains the standard library function takeIf which in my opinion is pretty straightforward but not well-known among developers because we don\u0026rsquo;t have a lot of other languages with similar constructs. Using it brings no overhead too but makes the code more declarative and allows chaining functions' calls in multiple situations.\nAdditionally, let\u0026rsquo;s notice that we defined the data class Cmd which is destructured in fold transformation as (dir, v) - that\u0026rsquo;s one of beauties of data classes that we should not forget about and don\u0026rsquo;t worry about introducing new, local types for such transformations.\n","date":"2021-12-02T00:00:00Z","image":"https://procyk.in/post/advent-of-code-2021-2/featured_hu3072977668770803714.jpg","permalink":"https://procyk.in/post/advent-of-code-2021-2/","title":"Advent of Code 2021 in Kotlin - Day 2"},{"content":"Introduction We start with Day 1 problem for which the solution is based on the template from the last year Advent of Code. Let\u0026rsquo;s begin to see some cool features of modern language - Kotlin ðŸ˜Ž.\nSolution We solve the problem in pretty straightforward way - we analyze the input data in windows of different sizes. In the first part it\u0026rsquo;s enough to analyze the windows of size = 2 and count how many of them contains increase.\nIn the second part, we add extra step before counting the difference - we need to calculate the sums of windows of size = 3. Then, the solution is the same as in the first part.\nDay1.kt 1 2 3 4 5 6 7 8 9 10 11 12 13 14 object Day1 : AdventDay() { override fun solve() { val depths = reads\u0026lt;Int\u0026gt;() ?: return depths.asSequence().countIncreases().printIt() depths.asSequence().countSumIncreases().printIt() } private fun Sequence\u0026lt;Int\u0026gt;.countIncreases() = windowed(size = 2) .count { (prev, curr) -\u0026gt; curr \u0026gt; prev } private fun Sequence\u0026lt;Int\u0026gt;.countSumIncreases(size: Int = 3) = windowed(size) .map { it.sum() } .countIncreases() } Extra notes Let\u0026rsquo;s see that we used Sequence\u0026lt;T\u0026gt; when solving the problem. It\u0026rsquo;s worth recalling that multiple operations on items in iterables should be implemented with usage of sequences because only in this way we can use the functional programming style and not cause the quadratic complexity of our solutions.\nAlso in countIncreases we could use the zipWithNext function, but it\u0026rsquo;s not required because of the feature of lists in Kotlin standard library. I want to recall that they can be destructured with componentN() functions as Pair\u0026lt;K, V\u0026gt; and that\u0026rsquo;s what we do in (prev, curr) -\u0026gt; curr \u0026gt; prev lambda definition. It\u0026rsquo;s worth mentioning that these componentN() functions can be defined also in our classes, so keep this in your mind when designing some Kotlin library API that could benefit from using these constructs ðŸ˜‰.\n","date":"2021-12-01T00:00:00Z","image":"https://procyk.in/post/advent-of-code-2021-1/featured_hu401861808896431747.jpg","permalink":"https://procyk.in/post/advent-of-code-2021-1/","title":"Advent of Code 2021 in Kotlin - Day 1"},{"content":"Presentation I\u0026rsquo;ve prepared some academic presentation about Kotlin, its constructs and some pretty examples of how to use the language idiomatically. Enjoy it and let me know what do you think about this way of presenting the language for some wider audience ðŸ˜‰.\nPrevious / Next Download ","date":"2021-11-15T00:00:00Z","image":"https://procyk.in/post/kotlin-presentation/featured_hu17703046906804694497.jpg","permalink":"https://procyk.in/post/kotlin-presentation/","title":"Kotlin Presentation"},{"content":"Introduction We can look at the Day 5 problem as on the binary definition of seats numbers with predefined letters instead of 0s and 1s.\nSolution By going through given seat definition as an iterable of characters, we can divide our predefined space range into halves and that\u0026rsquo;s what we start with by using String.findPlace(): Int?. The function returns null if is impossible to define the place - the range of matching places has more than single element. It uses a helper function String.select which is its actual implementation - it goes through the characters of given String and selects the proper part of range, based on its arguments low and high.\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 object Day5 : AdventDay() { override fun solve() { val lines = reads\u0026lt;String\u0026gt;() ?: return val places = lines.mapNotNull { it.findPlace() } places.maxOrNull().printIt() places.findGap().printIt() } } fun String.findPlace(): Int? { val row = select(0, 127, \u0026#39;F\u0026#39;, \u0026#39;B\u0026#39;) ?: return null val col = select(0, 7, \u0026#39;L\u0026#39;, \u0026#39;R\u0026#39;) ?: return null return row * 8 + col } fun String.select(from: Int, to: Int, low: Char, high: Char): Int? = fold(Pair(from, to)) { (f, t), c -\u0026gt; when (c) { low -\u0026gt; Pair(f, (f + t) / 2) high -\u0026gt; Pair((f + t) / 2 + 1, t) else -\u0026gt; Pair(f, t) } }.run { if (first == second) first else null } fun List\u0026lt;Int\u0026gt;.findGap(): Int? = sorted().windowed(3) .firstOrNull { it[0] + 1 != it[1] || it[1] + 1 != it[2] } ?.let { if (it[0] + 1 != it[1]) it[0] + 1 else it[1] + 1 } The first part is as easy as finding the biggest number of seat, which can easily by done with Kotlin extension function fun \u0026lt;T : Comparable\u0026lt;T\u0026gt;\u0026gt; Iterable\u0026lt;T\u0026gt;.maxOrNull(): T?.\nIn the second part we need to find the gap in the seats numbering. In such problems it\u0026rsquo;s usually a good idea to sort the items that we are processing, as this costs only $O(n \\log n)$ time, so it\u0026rsquo;s not so much compared to $O(n)$ which is required for input data processing. Having the seats sorted, finding a gap is as easy as finding a 3 elements window slice for which elements $(x, y, z)$ it\u0026rsquo;s not true that $x + 1 = y$ and $y + 1 = z$.\nExtra code comments There are two things in the task solution that are worth mentioning:\nWe should remember of using the sequences when making multiple operations on iterables in Kotlin. In this example it isn\u0026rsquo;t crucial but let\u0026rsquo;s notice that this can be easily achieved with single call of extension function fun \u0026lt;T\u0026gt; Iterable\u0026lt;T\u0026gt;.asSequence(): Sequence\u0026lt;T\u0026gt; as most of the functions available for collections are also available for sequences. It\u0026rsquo;s worth mentioning how the fold function works and why it\u0026rsquo;s used here. When we think about processing some data in a loop by iterating over it and holding accumulated value during that process, fold is usually the best way to express our intention. It can be simply defined for Iterable\u0026lt;T\u0026gt; as we find it in standard library 1 2 3 4 5 fun \u0026lt;T, R\u0026gt; Iterable\u0026lt;T\u0026gt;.fold(init: R, process: (acc: R, T) -\u0026gt; R): R { var acc = init for (element in this) acc = process(acc, element) return acc } which originally it\u0026rsquo;s defined as inline function, so this approach doesn\u0026rsquo;t bring extra cost but makes our code more readable. ","date":"2021-10-11T00:00:00Z","image":"https://procyk.in/post/advent-of-code-2020-5/featured_hu15832780621383757593.jpg","permalink":"https://procyk.in/post/advent-of-code-2020-5/","title":"Advent of Code 2020 in Kotlin - Day 5"},{"content":"Introduction The Day 4 problem might be seen as a business problem that requires reading some input data from the user, parsing it and performing business transformations.\nWe can try to realize that using some readable approach with the usage of extension functions and defining a few typealiaseses which would express our intentions.\nSolution Let\u0026rsquo;s start with the code solution\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 object Day4 : AdventDay() { override fun solve() { val lines = reads\u0026lt;String\u0026gt;() ?: return val passports = lines .split { it.isBlank() } .mapNotNull { it.toPassport() } passports.count { it.hasFields() }.printIt() passports.count { it.hasValidFields() }.printIt() } } private typealias Passport = Map\u0026lt;String, String\u0026gt; private typealias FieldCheck = (String) -\u0026gt; Boolean fun List\u0026lt;String\u0026gt;.toPassport(): Passport? = joinToString(separator = \u0026#34; \u0026#34;).run { takeIf { isNotBlank() }?.run { split(\u0026#34; \u0026#34;).associate { val field = it.split(\u0026#34;:\u0026#34;) field[0] to field[1] } } } val REQUIRED_FIELDS_CHECKS = mapOf( \u0026#34;byr\u0026#34; to ranged(4, 1920..2002), \u0026#34;iyr\u0026#34; to ranged(4, 2010..2020), \u0026#34;eyr\u0026#34; to ranged(4, 2020..2030), \u0026#34;hgt\u0026#34; to { val value = it.takeWhile(Char::isDigit).value\u0026lt;Int\u0026gt;() val type = it.dropWhile(Char::isDigit) (type == \u0026#34;cm\u0026#34; \u0026amp;\u0026amp; value in 150..193) || (type == \u0026#34;in\u0026#34; \u0026amp;\u0026amp; value in 59..76) }, \u0026#34;hcl\u0026#34; to { v -\u0026gt; v.length == 7 \u0026amp;\u0026amp; v[0] == \u0026#39;#\u0026#39; \u0026amp;\u0026amp; v.drop(1).all { it in \u0026#39;0\u0026#39;..\u0026#39;9\u0026#39; || it in \u0026#39;a\u0026#39;..\u0026#39;f\u0026#39; } }, \u0026#34;ecl\u0026#34; to { it in setOf(\u0026#34;amb\u0026#34;, \u0026#34;blu\u0026#34;, \u0026#34;brn\u0026#34;, \u0026#34;gry\u0026#34;, \u0026#34;grn\u0026#34;, \u0026#34;hzl\u0026#34;, \u0026#34;oth\u0026#34;) }, \u0026#34;pid\u0026#34; to { it.length == 9 \u0026amp;\u0026amp; it.all(Char::isDigit) }, ) fun ranged(digits: Int, range: IntRange): FieldCheck = { if (it.length == digits \u0026amp;\u0026amp; it.all(Char::isDigit)) it.value() in range else false } fun Passport.hasFields() = keys.containsAll(REQUIRED_FIELDS_CHECKS.keys) fun Passport.hasValidFields() = hasFields() \u0026amp;\u0026amp; REQUIRED_FIELDS_CHECKS.all { this[it.key]?.let(it.value) ?: true } Extra code comments We should start with the input data format that is given in unusual way because particular passports can be defined in a few lines. Because of that we have to split the input on blank lines and concatenate the adjacent lines to each other to get the complete passport definitions.\nNext we can convert the passport definitions into proper data structure that represents particular fields in passport with Map\u0026lt;String, String\u0026gt;. Using extension functions seems to be a good approach for this problem because we use only some defined data structure (i.e. Map\u0026lt;String, String\u0026gt;) without defining new class. Thanks to the Kotlin syntax we can use them later by calling on particular passports objects. We know from Kotlin documentation that these functions are implemented as syntax sugar static functions on JVM that take caller object as the first argument. We can also observe that using great tool in Intellij IDE for showing some bytecode that corresponds to selected part of code. To use it, it\u0026rsquo;s enough to select some function and call the action (with Ctrl + Shift + A/Cmd + Shift + A) named Show Kotlin Bytecode. Using that tool we see, that for example in case of the simplest Passport::hasFields function the compiled Kotlin bytecode looks like\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 public final static hasFields(Ljava/util/Map;)Z @Lorg/jetbrains/annotations/NotNull;() L0 ALOAD 0 LDC \u0026#34;$this$hasFields\u0026#34; INVOKESTATIC kotlin/jvm/internal/Intrinsics.checkNotNullParameter (Ljava/lang/Object;Ljava/lang/String;)V L1 LINENUMBER 46 L1 ALOAD 0 INVOKEINTERFACE java/util/Map.keySet ()Ljava/util/Set; (itf) GETSTATIC Day4Kt.REQUIRED_FIELDS_CHECKS : Ljava/util/Map; INVOKEINTERFACE java/util/Map.keySet ()Ljava/util/Set; (itf) CHECKCAST java/util/Collection INVOKEINTERFACE java/util/Set.containsAll (Ljava/util/Collection;)Z (itf) IRETURN L2 LOCALVARIABLE $this$hasFields Ljava/util/Map; L0 L2 0 MAXSTACK = 2 MAXLOCALS = 1 The most interesting for us parts of this code are:\nfunction is declared as static final function function takes a Map object as its argument and uses it later by calling ALOAD 0 which strictly corresponds to our theoretical knowledge of the extension functions in Kotlin.\nBy the way, we can observe that the first part of this function is checking if it\u0026rsquo;s first argument (i.e. Passport caller object) is null or not, because it was defined as not nullable type. It\u0026rsquo;s worth recalling that these Kotlin checks for nullability are not only the compiler checks, but they also result in extra checks in runtime of our code ðŸ˜‰\n","date":"2021-10-10T00:00:00Z","image":"https://procyk.in/post/advent-of-code-2020-4/featured_hu6052901795502801923.jpg","permalink":"https://procyk.in/post/advent-of-code-2020-4/","title":"Advent of Code 2020 in Kotlin - Day 4"},{"content":"Introduction The Day 3 presents a problem of traversing in some regular way through the given data structure. In our case it\u0026rsquo;s just an ordered collections of Strings that can be seen as a matrix of chars which are traversed in 2 dimensions.\nWe have to check how many of the \u0026ldquo;trees\u0026rdquo; would we encounter during the walk over given structure.\nSolution Traditionally, we begin with a code solution and the approach to problem becomes pretty straightforward - we simulate all the steps of the walk and verify what\u0026rsquo;s on our current position.\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 object Day3 : AdventDay() { override fun solve() { val lines = reads\u0026lt;String\u0026gt;() ?: return (3 to 1 steppedIn lines).printIt() listOf( 1 to 1, 3 to 1, 5 to 1, 7 to 1, 1 to 2, ) .map { it steppedIn lines } .fold(1L, Long::times) .printIt() } } infix fun Pair\u0026lt;Int, Int\u0026gt;.steppedIn(lines: List\u0026lt;String\u0026gt;): Int { val (x, y) = this return generateSequence(0, Int::inc) .takeWhile { it * y \u0026lt; lines.size } .count { val line = lines[it * y] line[(it * x) % line.length] == \u0026#39;#\u0026#39; } } Personal thoughts We can notice a few small features of Kotlin code that make it more pleasant to be read in this task\u0026rsquo;s code snippet.\nNotice first the usage of the created infix fun that was created with this approach only for the readability of the code. It allowed us to write 3 to 1 steppedIn lines which can be understood as \u0026ldquo;make (3, 1) steps on the given map representation\u0026rdquo;. It\u0026rsquo;s even more readable when defined for the collection of different steps that we execute for the second task.\nMore interesting part is the concept of Sequence\u0026lt;T\u0026gt; in programming languages. We should remember, that the sequence is somehow different from collection, because it\u0026rsquo;s processed lazily. It brings extra cost which is noticeable only when the sequence is pretty small. Let\u0026rsquo;s visit the Kotlin sequences documentation to see great illustration of the approach to collections processing by sequences.\nWe should notice the possibility to work with sequences every time we process some more regular collection of data that requires some modifications of its elements in separate steps. In this task, approach that uses sequences really simplifies the solution code and allows us to express our intentions directly - simulate stepping down through the map while we are still on the map and count the number of fields on which we see the '#''.\nAnd finally, notice how the pair is destructured to its elements - it\u0026rsquo;s quite common to use this feature for Pair\u0026lt;T, U\u0026gt; or Triple\u0026lt;T, U, V\u0026gt; but we can use it for any class that has the proper operator implementation (see full description in Kotlin documentation) and the data classes offer implementation to its components for free ðŸ•¶.\n","date":"2021-10-07T00:00:00Z","image":"https://procyk.in/post/advent-of-code-2020-3/featured_hu15181229165927953078.jpg","permalink":"https://procyk.in/post/advent-of-code-2020-3/","title":"Advent of Code 2020 in Kotlin - Day 3"},{"content":"Introduction The Day 2 tasks seems to be pretty straightforward - we only need to check the defined rules for given passwords according to task description. We will try to express the solution in pretty straightforward way by recalling some less known Kotlin functions.\nSolution We can present the whole solution in a few lines of code which use already defined inline fun \u0026lt;reified T\u0026gt; String.value(): T in order to neatly convert input parts to actual numbers.\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 object Day2 : AdventDay() { override fun solve() { val defines = reads\u0026lt;String\u0026gt;() ?: return defines.count { it.isValidOld() }.printIt() defines.count { it.isValidNew() }.printIt() } } fun String.isValidOld(): Boolean { val parts = split(\u0026#34; \u0026#34;) val letter = parts[1][0] val range = parts[0].split(\u0026#39;-\u0026#39;).map { it.value\u0026lt;Int\u0026gt;() } return parts[2].count { it == letter } in range[0]..range[1] } fun String.isValidNew(): Boolean { val parts = split(\u0026#34; \u0026#34;) val letter = parts[1][0] val positions = parts[0].split(\u0026#39;-\u0026#39;).map { it.value\u0026lt;Int\u0026gt;() } val onFst = parts[2][positions[0] - 1] == letter val onSnd = parts[2][positions[1] - 1] == letter return onFst xor onSnd } Worth noting Let\u0026rsquo;s deep dive into two snippets of this solution to improve our familiarity with Kotlin:\nKeyword in can be used not only to iterate over a loop, but also to check if the value belongs to something. Basically, we need to have operator fun T.contains(element: U): Boolean in order to be able to check if some value u: U belongs to some other value t: T by simply calling u in t. It\u0026rsquo;s a great moment to remind the Kotlin\u0026rsquo;s documentation about operators and their usages - using them in our code can make it not only shorter but also more readable and easier to explain for non-programming people. Notice the usage of xor function in 2nd part of the solution. It\u0026rsquo;s not common to see it in code from my perspective because it can be expressed e.g. as (b1 \u0026amp;\u0026amp; !b2) || (!b1 \u0026amp;\u0026amp; b2) with the standard operators, but we should remember the KISS rule and try to express our thoughts in the most readable way - it can be done with this pretty function in really neat way. Additionally, we can see some other functions predefined for Boolean like and or not and revisit the Kotlin\u0026rsquo;s documentation about infix notation - they allow creating really readable code with almost no extra overhead. ","date":"2021-10-06T00:00:00Z","image":"https://procyk.in/post/advent-of-code-2020-2/featured_hu18054762938120459177.jpg","permalink":"https://procyk.in/post/advent-of-code-2020-2/","title":"Advent of Code 2020 in Kotlin - Day 2"},{"content":"Introduction We start with Day 1 for which we can show two really different approaches and the final decision which one could be used in production code should be made depending on the expected inputs for our program and the expected readability of the code in our codebase.\nBrute force approach We start with naive approach to solve the task and see that it\u0026rsquo;s enough for our input data to get the proper answer in really short time.\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 object Day1 : AdventDay() { override fun solve() { val numbers = reads\u0026lt;Long\u0026gt;() ?: return numbers.solveFor2(2020).printIt() numbers.solveFor3(2020).printIt() } } fun List\u0026lt;Long\u0026gt;.solveFor2(sum: Long): Long { for (i in indices) for (j in indices) if (i != j \u0026amp;\u0026amp; this[i] + this[j] == sum) return this[i] * this[j] throw IllegalStateException(\u0026#34;Solution not found\u0026#34;) } fun List\u0026lt;Long\u0026gt;.solveFor3(sum: Long): Long { for (i in indices) for (j in indices) for (k in indices) if (i != j \u0026amp;\u0026amp; j != k \u0026amp;\u0026amp; k != i \u0026amp;\u0026amp; this[i] + this[j] + this[k] == sum) return this[i] * this[j] * this[k] throw IllegalStateException(\u0026#34;Solution not found\u0026#34;) } The problem is that the complexity of these approaches is $O(n^2)$ and $O(n^3)$. From my point of view this approach seems to be the most readable despite maybe not being Kotlin idiomatic. We just wrote really concise and readable code that simply solves our problem and get the answer.\nSmarter approach Let\u0026rsquo;s think about rephrasing our problem statement - maybe we should check if for any of input number $n$ there is some other number that equals $2020 - n$. We can express this approach also with just a few lines of Kotlin code for the first part of the task\n1 2 3 4 5 6 7 8 9 fun List\u0026lt;Long\u0026gt;.solveFasterFor2(sum: Long): Long { val count = countOccurrences() return toSet().firstOrNull { n -\u0026gt; val rest = sum - n (rest != n \u0026amp;\u0026amp; count[rest]!! \u0026gt; 0) || (rest == n \u0026amp;\u0026amp; count[rest]!! \u0026gt; 1) } ?.let { it * (sum - it) } ?: throw IllegalStateException(\u0026#34;Solution not found\u0026#34;) } But what is needed for it to work we need to define countOccurrences function with some pretty simple but really useful DefaultMap class which could be used for future tasks too.\n1 2 3 4 5 6 7 fun \u0026lt;T\u0026gt; Iterable\u0026lt;T\u0026gt;.countOccurrences(): DefaultMap\u0026lt;T, Long\u0026gt; = mutableMapOf\u0026lt;T, Long\u0026gt;().also { map -\u0026gt; forEach { map[it] = map.getOrDefault(it, 0) + 1 } }.let { DefaultMap(0, it) } class DefaultMap\u0026lt;K, V\u0026gt;(private val default: V, private val delegate: Map\u0026lt;K, V\u0026gt;) : Map\u0026lt;K, V\u0026gt; by delegate { override fun get(key: K): V? = delegate.getOrDefault(key, default) } Some similar but less readable approach can also be used to find the solution for 3 numbers - we will skip it anyway as we already got our advent stars, and it\u0026rsquo;s definitely enough advent coding for today.\n","date":"2021-10-05T00:00:00Z","image":"https://procyk.in/post/advent-of-code-2020-1/featured_hu6528079612931170907.jpg","permalink":"https://procyk.in/post/advent-of-code-2020-1/","title":"Advent of Code 2020 in Kotlin - Day 1"},{"content":"Introduction Last year I realized about the existence of great initiative that is the Advent of Code - but it was too late to do it on time. So I left the event only looking for the defined tasks (also hearing about them at great YouTube channel Tsoding Daily - look and subscribe, this guy does the job).\nThis year has to be different and I will do my best not to forget about it ðŸ˜‹.\nBut to be well-prepared for this event it\u0026rsquo;s always a good strategy to look into the previous editions and try to analyze some old tasks. I\u0026rsquo;d like to solve all of them as a part of this series of posts and try to do it in the most Kotlin idiomatic approach but taking also performance into account.\nThe solutions will be published as a git repository after solving full series in order to simplify the process of running them but for now focus on the ideas that can be presented with these small pieces of code.\nSolution template One of the main rules in programming is DRY - don\u0026rsquo;t repeat yourself. We try to rewrite our code to remove the repeated parts and abstract its parts that can be reused. The main repeatable part of our solutions will be definitely the AdventDay which will contains our solutions\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 sealed class AdventDay(private val readFromStdIn: Boolean = false) { abstract fun solve() inline fun \u0026lt;reified T\u0026gt; reads() = getInputLines()?.map { it.value\u0026lt;T\u0026gt;() } fun getInputLines() = if (readFromStdIn) generateSequence { readLine() }.toList() else this::class.java.getResource(\u0026#34;/input/${this::class.java.simpleName}.in\u0026#34;) ?.openStream()?.bufferedReader()?.readLines() } inline fun \u0026lt;reified T\u0026gt; String.value(): T = when (T::class) { String::class -\u0026gt; this as T Long::class -\u0026gt; toLongOrNull() as T Int::class -\u0026gt; toIntOrNull() as T else -\u0026gt; TODO(\u0026#34;Add support to read ${T::class.java.simpleName}\u0026#34;) } We use sealed class which can have subclasses definitions in the same compilation module and same package as the sealed class. Using a few lines of code we can define the main entrypoint of our solutions which will be capable of running all AdventDays without explicitly specifying them - it\u0026rsquo;ll be enough to inherit from our AdventDay class and implement solve to see the solution on console output.\n1 2 3 4 5 6 7 fun main() = AdventDay::class.sealedSubclasses .mapNotNull { it.objectInstance } .sortedBy { it::class.java.simpleName.removePrefix(\u0026#34;Day\u0026#34;).toInt() } .forEach { println(\u0026#34;--- ${it::class.java.simpleName}\u0026#34;) it.solve() } Using this template we can create objects as the subclasses of the AdventDay in order to have the instance of them always available and simply run our solution.\n","date":"2021-10-04T00:00:00Z","image":"https://procyk.in/post/advent-of-code-2020-0/featured_hu5261084723930768810.jpg","permalink":"https://procyk.in/post/advent-of-code-2020-0/","title":"Advent of Code 2020 in Kotlin - Introduction"}]